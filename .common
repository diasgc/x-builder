#!$SHELL
# ................................................
# Commons 0.3.1 2021-diasgc
# Definition constants and functions
# ................................................

vsh='0.3.1'

#b="\u25ba"
b="\u2605"
c="\u2714"
# def colors
C0="\e[0m" CW="\e[97m"  CD="\e[90m" CW2="\e[38;5;234m" CW3="\e[38;5;238m" CW4="\e[38;5;242m"  CW5="\e[38;5;246m" CW6="\e[38;5;250m"
CR0="\e[31m" CR1="\e[91m" CR2="\e[38;5;52m" CR3="\e[38;5;88m" CR4="\e[38;5;124m" CR5="\e[38;5;160m"  CR6="\e[38;5;196m"
CY0="\e[33m" CY1="\e[93m" CY2="\e[38;5;58m" CY3="\e[38;5;94m" CY4="\e[38;5;136m" CY5="\e[38;5;178m"  CY6="\e[38;5;220m"
CG0="\e[32m" CG1="\e[92m" CG2="\e[38;5;46m" CG3="\e[38;5;82m" CG4="\e[38;5;118m" CG5="\e[38;5;154m"  CG6="\e[38;5;190m"
CC0="\e[36m" CC1="\e[96m" CC2="\e[38;5;49m" CC3="\e[38;5;85m" CC4="\e[38;5;122m" CC5="\e[38;5;123m"  CC6="\e[38;5;195m"
CB0="\e[34m" CB1="\e[94m" CB2="\e[38;5;26m" CB3="\e[38;5;69m" CB4="\e[38;5;111m" CB5="\e[38;5;152m"  CB6="\e[38;5;153m"
CM0="\e[35m" CM1="\e[95m" CM2="\e[38;5;54m" CM3="\e[38;5;91m" CM4="\e[38;5;126m" CM5="\e[38;5;162m"  CM6="\e[38;5;198m"

CO0="\e[38;5;130m" CO1="\e[38;5;166m" CO2="\e[38;5;202m" CO3="\e[38;5;208m"  CO4="\e[38;5;214m" CO5="\e[38;5;220m" CO6="\e[38;5;223m"
CF0="\e[38;5;53m"  CF1="\e[38;5;89m"  CF2="\e[38;5;125m" CF3="\e[38;5;161m"  CF4="\e[38;5;197m" CF5="\e[38;5;211m" CF6="\e[38;5;219m"
CL0="\e[38;5;34m" CL1="\e[38;5;72m" CL2="\e[38;5;114m" CL3="\e[38;5;120m"  CL4="\e[38;5;156m" CL5="\e[38;5;192m" CL6="\e[38;5;230m"

# theme colors
CT0=$CM0 CT1=$CM1 CS0=$CR0 CS1=$CR1 SSB=$C0

banner(){
    echo -ne "\n\n  ${CW}${1} for X-Builder ${vsh}${C0}\n  "
    echo -ne "Running on $(uname -m) $(uname -o) "
    [ -n $(which lsb_release) ] && echo -ne "$(lsb_release -sd) "
    if [ -n "$(uname -r | grep 'microsoft')" ];then
        echo -ne "${CD}WSL2 "
    elif [ -n "$(uname -r | grep 'Microsoft')" ];then
        echo -ne "${CD}WSL "
    else
        echo -ne "${CD} "
    fi
    echo -e "$(uname -r)${C0}\n"
}

ifdef_function(){
  [ "$(type -t $1)" = 'function' ]
}

git_getversion(){
  [ -d "${1}" ] && git --git-dir=${1}/.git --work-tree=${1} describe --abbrev=0 --tags || git describe --abbrev=0 --tags
}

str_contains(){
   [ -z "${1##*${2}*}" ]
}

str_starts(){
   [ "${1#${2}}" != "${1}" ]
}

str_ends(){
   [ "${1%${2}}" != "${1}" ]
}

str_lowercase(){
  echo ${1} | tr '[:upper:]' '[:lower:]'
}

str_uppercase(){
  echo ${1} | tr '[:lower:]' '[:upper:]'
}

pushvar_f(){
  var_addl $@
}

pushvar_l(){
  var_addr $@
}

popvar_f(){
  local n=$1
  local v=( ${!1} )
  case ${#v[@]} in
    0) echo;;
    1) echo $v; eval $n=;;
    *) local p="${v%% *} "
       echo $p
       eval $n=\"${v#$p}\"
       ;;
  esac
}

popvar_l(){
  local n=$1
  local v=( ${!1} )
  case ${#v[@]} in
    0) echo;;
    1) echo $v; eval $n=;;
    *) local p="${v## *} "
       echo $p
       eval $n=\"${v%$p}\"
       ;;
  esac
}

pushdir(){
  case $SHELL in
    *bash) pushd $1 >/dev/null 2>&1;;
    *) pushvar_f shell_dstack $1; cd $1;;
  esac
}

popdir(){
  case $SHELL in
    *bash) popd >/dev/null 2>&1;;
    *) local d=$(popvar_f shell_dstack); [ -n "$d" ] && cd $d;;
  esac
}

prt_progress(){
  printf "%-6s"
  while read -r ln; do
    printf "\e[6D%-6s" $(grep -oP '\d+%' <<< $ln)
  done
  printf "\e[6D"
}

inc_tab(){
  indent=$(expr "$indent" + 2)
  ind=$(printf '%*s' "$indent")
}

dec_tab(){
  indent=$(expr "$indent" - 2)
  [ $indent -gt 0 ] && ind=$(printf '%*s' "$indent") || unset ind
}

# exclusive variable add substrings left var_xaddl <var> <substrings...>
# appends substrings to the left/start of var iff main doesnt contains substring
var_xaddl(){
  local v=$1; shift
    while [ -n "$1" ];do
        [ -z "${!v##*${1}*}" ] || eval $v=\"${1} ${!v}\"
        shift
    done
}

# exclusive variable add substrings right var_xaddl <var> <substrings...>
# appends substrings to the right/end of var variable iff main doesnt contains substring
var_xaddr(){
    local v=$1; shift
    while [ -n "$1" ];do
        [ -z "${!v##*${1}*}" ] || eval $v=\"${!v} ${1} \"
        shift
    done
}

var_addr(){
    local v=$1; shift; eval $v=\"${!v} $@\"
}

var_addl(){
    local v=$1; shift; eval $v=\"$@ ${!v}\"
}

# vercomp v1 v2 returns 0: v1=v2, 1: v1>v2, 2: v1<v2
vercomp () {
    test "$1" = "$2" && return 0
    local IFS=.
    local i ver1=($1) ver2=($2)
    # fill empty fields in ver1 with zeros
    for ((i=${#ver1[@]}; i<${#ver2[@]}; i++)); do
        ver1[i]=0
    done
    for ((i=0; i<${#ver1[@]}; i++)); do
        test -z "${ver2[i]}" && ver2[i]=0
        if ((10#${ver1[i]} > 10#${ver2[i]})); then return 1; fi
        if ((10#${ver1[i]} < 10#${ver2[i]})); then return 2; fi
    done
    return 0
}