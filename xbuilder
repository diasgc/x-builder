#!/bin/sh
# ................................................
# X-Builder util 0.3.1 2021-diasgc
# ................................................

init(){

  [ -z ${set_def+x} ] && set_def=

  set -${set_def}o pipefail
  . .common

  trap err ERR
  [ -z ${ndk_api+x} ] && ndk_api=24
  [ -z ${debug+x} ] && debug=false
  [ -z ${nodev+x} ] && nodev=false
  [ -z ${is_init+x} ] && is_init=false
  [ -z ${pkg+x} ] && pkg=${lib}
  [ -z ${apt+x} ] && apt=${lib}
  [ -z ${ac_nohost+x} ] && ac_nohost=false
  [ -z ${lib_noshared+x} ] && lib_noshared=false

  install_tree=false
  cmake_build_type=Release
  cmake_toolchain_file=
  banner=true
  mingw_posix_suffix=
  use_llvm_mingw=true
  use_ndk_cmake=false
  use_clang=true
  req_src_nodev=false
  req_src_clone=false
  req_src_update=false
  req_src_update_deps=false
  req_src_config=false
  req_src_patch=false
  req_bld_retry=false

  build_shared=false
  build_static=false
  build_bin=false
  build_docs=false

  no_host=false
  ac_nohost=false
  ac_nosysroot=false
  build_package=true
  break_on_source=false
  pc_filelist=
  shell_dstack=
  stack_version=
  CFG=
  CSH=
  CBN=
  args_root=$@

  rootdir="$(pwd)"
  distpkg="${rootdir}/packages"
  [ -d "${distpkg}" ] || mkdir -p ${distpkg}
  
  sources="${rootdir}/sources"
  [ -d "${sources}" ] || mkdir -p ${sources}

  builds="${rootdir}/builds"
  [ -d "${builds}" ] || mkdir -p ${builds}
  
  [ -f ".config" ] && . .config
  if [ ! -f ".config" ] || test `expr $(date +%s) - $config_lastupdate` -gt 86400; then
    ./xsetup.sh
    . .config || err 'Unable to initialize config file'
  fi
  log_time_global=$(date +%s)
  ind=0
  [ -n "${lib+x}" ] && {
    banner ${lib^^}
    source_dir="${sources}/${lib}"
  }
}

[ -z ${vsh+x} ] && init
inc_tab

start(){
  
  ${debug} && set -x
  ! $req_src_update && package_check_files && exit 0

  if [ -n "${dep+x}" ];then
    if [ -n "${vrs+x}" ];then
      pushvar_f stack_version ${vrs}
      build_dependencies ${dep}
      vrs=$(popvar_f stack_version)
    else
      build_dependencies ${dep}
    fi
  fi

  $req_src_update && rm -rf ${source_dir}

  banner_packageinfo
  log_init "${packages_dir}/${lib}.log"

  echo -ne "${C0}${ind}$(date '+%H:%M')"
  [ -n "${eta+x}" ] && echo -ne "-${CW}$(date '+%H:%M' --date="${eta} seconds")"
  printf " ${CT1}%-10s ${CT1}%-21s${CD} " ${lib} ${host_arch}

  local bss=
  $build_static && bss="${SSB}[static]" || bss="${CD}[static]"
  $build_shared && bss="${bss}${SSB}[shared]" || bss="${bss}${CD}[shared]"
  $build_bin && echo -ne "${bss}${SSB}[bin]${C0} " || echo -ne "${bss}${CD}[bin]${C0} "
  
  cd $sources

  if [ ! -d $source_dir ];then
    
    if [ -z ${sty+x} ];then
      case $src in
        *git) sty='git';;
        *.tar*) sty='tar';;
        *svn.*) sty='svn';;
        *) err "unkown ${src} source type to clone";;
      esac
    fi
    
    # check whether to custom source get
    isfn_defined 'source_get' && source_get || def_source_get
    req_src_config=true
    req_src_patch=true
  fi
  
  # following functions and commands will execute under $source_dir
  cd $source_dir

  # guess build type if none defined
  if [ -z ${cfg+x} ] || [ "${cfg,,}" == "auto" ]; then
    if [ -f "configure" ];then
      cfg="ac"
    elif [ -f "autogen.sh" ]; then
      cfg="autogen"
    elif [ -f "configure.{in|ac}" ]; then
      cfg="autoreconf"
    elif [ -f "CMakeLists.txt" ]; then
      cfg="cmake"
    elif [ -f "meson.build" ]; then
      cfg="meson"
    fi
  fi

    # set build_dir if none is set
  case ${cfg} in
    automake|ac|ar|ag)
      [ -z ${build_dir+x} ] && build_dir="${source_dir}"
      build_tool='automake'
      ;;
    cmake|ccmake|cm|ccm)
      [ -z ${build_dir+x} ] && build_dir="${source_dir}/build_${host_arch}"
      build_tool='cmake'
      ;;
    meson)
      [ -z ${build_dir+x} ] && build_dir="${source_dir}/build_${host_arch}"
      build_tool='meson'
      ;;
    mk|make)
      build_dir="${source_dir}"
      build_tool='make'
      ;;
    *)
      build_dir="${source_dir}"
      build_tool='ignore'
      ;;
  esac

  if $req_src_config;then
    # check whether to custom source config
    isfn_defined 'source_config' && source_config || def_source_config
    req_src_config=false
  fi

  if $req_src_patch; then
    # check whether to auto patch source
    #check_xbautopatch
    # check whether to custom patch source
    isfn_defined 'source_patch' && source_patch
    req_src_patch=false
  fi


  # clear build_dir if exists or not retrying to build
  if [ "${build_dir}" != "${source_dir}" ];then
    ! $req_bld_retry && [ -d "${build_dir}"] && rm -rf ${build_dir}
    mkdir -p ${build_dir}
  fi

  $break_on_source && end_script

  # following functions and commands will execute under $build_dir
  cd $build_dir

  logv dep PKG_CONFIG_LIBDIR
  logv CFLAGS CXXFLAGS CPPFLAGS LDFLAGS LIBS
  logv CC CXX LD AS AR NM RANLIB STRIP
  
  isfn_defined 'build_all' && {
    build_all
    end_script
  }

  isfn_defined 'build_prepare' && build_prepare

  isfn_defined 'build_clean' && build_clean || {
    [ -z ${mkc+x} ] && mkc="clean"
    [ -f "Makefile" ] && log --noerr 'clean' ${MAKE_EXECUTABLE} $mkc
  }
  
  isfn_defined 'build_config' && log 'prepare' build_config || \
    def_build_config

  isfn_defined 'build_patch_config' && log 'patch' build_patch_config

  # set -all-static flags at make time
  # ref: https://stackoverflow.com/questions/20068947/how-to-static-link-linux-software-that-uses-configure
  $use_clang && $build_static && LDFLAGS="-all-static ${LDFLAGS}"

  isfn_defined 'build_make' && log 'make' build_make || \
    log --progress 'make' ${MAKE_EXECUTABLE} ${mkf+x} -j${HOST_NPROC}

  isfn_defined 'patch_install' && patch_install

  [ -z ${mki+x} ] && mki="install"

  isfn_defined 'build_install' && log 'install' build_install || \
    log --progress 'install' ${MAKE_EXECUTABLE} ${mki}

  # check whether to create pkg-config .pc file
  if isfn_defined 'build_pkgconfig_file'; then
    log 'pkgcfg' build_pkgconfig_file
  elif [ -n "${pc_llib+x}" ];then
    log 'write_pc' create_pkgconfig_file ${pkg} ${pc_llib}
  fi

  # create package
  $build_package && log 'tar' build_packages_bin

  logver "${install_pc_dir}/${pkg}.pc"

  #stat_savestats
  end_script
}

end_script(){
  local dt=$(($(date +%s) - ${log_timestart}))
  echo -ne "${CT1} done ${CW}in ${dt}s"
  [ ${dt} -gt 60 ] && echo -e " ($(date -u -d @${dt} +"%m:%S"))" || echo
  # check if parent process is shell script
  local parent=$(ps -o comm= $PPID)
  [ "${parent: -3}" == ".sh" ] || echo -e "\n${ind}${CT1}::Done${C0}\n"
  $debug && set +x
  unset CSH CBN exec_config vrs
  dec_tab
  echo
  exit 0
}

def_source_get(){
  case ${sty} in
    git ) git_clone $src $lib;;
    tar|tgz|tlz|tbz) tar_get $src $lib;;
    svn) svn_clone $src $lib;;
    hg) hg_clone $src $lib;;
    *) err "unknown sty='$sty' for $src";;
  esac
}

topct(){
  printf "%-6s"
  local sln
  while read -r ln; do
    str_contains $ln 'error: ' && printf $CR1
    sln=$(grep -oP '\d+%' <<< $ln)
    [ -n "$sln" ] && printf "\e[5D%-5s" $sln
  done
  printf "\e[6D"
}

git_clone(){
  local label="git"
  echo -ne "${CD}${label}"
  git clone --progress --verbose $1 $2 ${src_opt+x} |& tr '\r' '\n' | topct
  echo -ne "\e[${#label}D${CT0}${label}${C0} "
  [ -d "$2" ] && cd $2 || err
  $req_src_nodev && vrs=$(git describe --abbrev=0 --tags)
  if [ -n "${vrs+n}" ];then
    log "${vrs}" git checkout tags/${vrs};
  fi
  cd ..
}

def_source_config(){
  [ -n "${cfg_cmd+x}" ] && log 'config' ${cfg_cmd}
  case ${cfg} in
    autogen|ag) export NOCONFIGURE=1; log 'autogen' ./autogen.sh;;
    autoreconf|ar) log 'autoconf' autoreconf -fiv;;
  esac
}

def_build_config(){
  case $build_tool in
    cmake)
      [ -z ${exec_config+x} ] && exec_config=${CMAKE_EXECUTABLE}
      [ -z ${cmake_toolchain_file+x} ] && cmake_create_toolchain "${build_dir}/toolchain.cmake"
      [ -f "${cmake_toolchain_file}" ] && CFG="-DCMAKE_TOOLCHAIN_FILE=${cmake_toolchain_file} $CFG"
      log 'cmake' ${exec_config} ${source_dir} -DCMAKE_INSTALL_PREFIX=${install_dir} -DCMAKE_BUILD_TYPE=${cmake_build_type} ${CFG} ${CSH} ${CBN}
      case $cfg in ccm|ccmake) tput sc; ccmake ..; tput rc;; esac
      ;;
    automake)
      [ -z ${exec_config+x} ] && exec_config='configure' # default config executable
      ! $ac_nohost && [ "${host_arch}" != "${build_arch}" ] && CFG="--host=${host_arch} $CFG"
      ac_nohost=false
      ! $ac_nosysroot && CFG="--with-sysroot=${host_sysroot} $CFG"
      log 'configure' ${build_dir}/${exec_config} --prefix=${install_dir} $CFG $CSH $CBN
      ;;
    meson)
      local MESON_EXEC=$(check_tool_dependency meson)
      [ -z "$MESON_EXEC" ] && err 'Could not install meson. Aborting.'
      local meson_toolchain_file="${source_dir}/${host_arch}.meson"
      [ -f "$MESON_CFG" ] && rm $MESON_CFG
      meson_create_toolchain ${meson_toolchain_file}
      log 'meson' ${MESON_EXEC} setup --buildtype=release --cross-file=${meson_toolchain_file} --prefix=${install_dir} $CFG $CSH $CBN
      ;;
    make)
      mkf=$CFG
      ;;
  esac
}

create_pkgconfig_file(){
    [ -z "${1}" ] && pc_file=${lib} || pc_file=${1}
    [ -z "${2}" ] && pc_llib="-l${pc_file}" || pc_llib=${2}
    [ -z ${pc_cflags+x} ] && pc_cflags="-I\${includedir}"
    [ -z ${pc_libs+x} ] && pc_libs="-L\${libdir}"
    [ -z ${pc_url+x} ] && pc_url=$(dirname ${src})
    [ -z ${pc_vrs+x} ] && {
      [ -d "${source_dir}/.git" ] && pc_vrs=$(git_getversion ${source_dir}) || pc_vrs=$vrs
    }
    cat <<-EOF >${install_pc_dir}/${1}.pc
		prefix=${install_dir}
		exec_prefix=\${prefix}
		libdir=\${exec_prefix}/lib
		includedir=\${prefix}/include

		Name: ${lib}
		Description: ${dsc}
		URL: ${pc_url}
		Version: ${pc_vrs}
    Requires: ${pc_requires}
    Requires.private: ${pc_requiresprivate}
		Libs: ${pc_libs} ${pc_llib}
    Libs.private: ${pc_libsprivate}
		Cflags: ${pc_cflags}
  
		EOF
    pc_filelist="${1}.pc ${pc_filelist}"
}

build_dependencies(){
  local pkgdir
  while [ -n "${1}" ]; do
    if [ -f "${1}.sh" ];then
      ./${1}.sh $args_root || err "Fail to build ${1}, aborting..."
      $install_tree && pkgdir="${packages_dir}/${1}/lib/pkgconfig" || pkgdir="${install_dir}/lib/pkgconfig"
      str_contains $PKG_CONFIG_LIBDIR ${pkgdir} || PKG_CONFIG_LIBDIR="${pkgdir}:${PKG_CONFIG_LIBDIR}"
    else
      err "there is no script file ${1}.sh, aborting..."
    fi
    shift
  done
}

build_packages_getdistdir(){
  [ -f "${install_pc_dir}/${pkg}.pc" ] && vrs=$(pkg-config ${install_pc_dir}/${pkg}.pc --modversion)
  [ -z ${vrs+x} ] && set_git_version
  echo "${rootdir}/packages/${lib}-${vrs}-${host_arch}"
}

build_packages_filelist(){
  local scfile="${rootdir}/${lib}.sh"
  if [ -z "$(cat $scfile | grep '# Filelist')" ]; then
    echo -e "\n\n# Filelist\n# --------" >> $scfile
    find ./ -type f | sed 's|^./|# |g' >> $scfile
  fi
}

build_packages_bin(){
  local xb_distdir=$(build_packages_getdistdir)
  if isfn_defined 'create_package'; then
    create_package $xb_distdir
  else
    if isfn_defined 'build_make_package'; then
      build_make_package $xb_distdir
    elif [ "${MAKE_EXECUTABLE}" = "ninja" ];then
      DESTDIR=${xb_distdir} ninja -C ${build_dir} install
    else
      [ -z "$mkd" ] && mkd="DESTDIR=${xb_distdir} install"
      ${MAKE_EXECUTABLE} $mkd
    fi
    [ -z "$mkd_suffix" ] && mkd_suffix=${install_dir}
    cd "${xb_distdir}${mkd_suffix}"
    
    # also include .pc manually-built file
    if isfn_defined 'build_pkgconfig_file' || [ -n "${pc_llib+x}" ];then
      local xb_pkgd="$(pwd)/lib/pkgconfig"
      [ ! -d "${xb_pkgd}" ] && mkdir -p ${xb_pkgd}
      if [ -n "${pc_filelist+x}" ];then
        for pp in ${pc_filelist}; do
          cp ${install_pc_dir}/${pp} ${xb_pkgd}/
        done
      else
        cp ${install_pc_dir}/${pkg}.pc ${xb_pkgd}/
      fi
    fi
    build_packages_filelist
    tar -czvf "${xb_distdir}.tar.gz" *
    rm -rf ${xb_distdir}
    cd ${build_dir}
  fi
}

package_check_files(){
  [ -n "$lst_pc" ] && for p in $lst_pc; do
    [ ! -f "$install_dir/lib/pkgconfig/$p" ] && return 1
  done
  [ -n "$lst_inc" ] && for i in $lst_inc; do
    [ ! -f "$install_dir/include/$i" ] && return 1
  done
  [ -n "$lst_lib" ] && for l in $lst_lib; do
    [ -z "$(ls $install_dir/lib/${l}.a*)" ] && return 1
    [ -z "$(ls $install_dir/lib/${l}.so*)" ] && return 1
  done
  return 0
}

logver() {
  if [ -f "${1}" ];then
    echo -ne "${CT1}version $(pkg-config --modversion ${1})${C0}"
  else
    echo -ne "${CS0} missing ${1} ${C0}"
  fi
}

banner_packageinfo(){
  local p_dsc=
  local p_vrs=
  local longdesc=$(get_longdesc)
  [ -n "${tls+x}" ] && p_dsc="${CT0}tools: ${C0}${tls} "
  [ -n "${dep+x}" ] && p_dsc="${p_dsc}${CT0}dependencies: ${C0}${dep}"
  if [ "${sty+x}" == "git" ] || str_contains $src 'git';then
    local vgit=$(git_remote_version ${src})
    if [ -d "${source_dir}" ];then
      vrs=$(git_local version ${source_dir})
      p_vrs="${CT0}vrs: ${C0}$vrs "
      str_contains $vgit $vrs && \
        pushvar_l pvers 'updated' || \
        pushvar_l pvers "$p_vrs ${CT0}latest is ${CT1}${vgit}${C0}"
    else
      p_vrs="${CT0}vrs: ${C0}${vgit}"
    fi
  fi
  echo -e "\n${CW}${ind}${lib^^} - ${C0}${dsc}"
  echo -e "${CD}${longdesc}" | sed 's|\*|\u2605|g; s|\..\..|. |g' # sed 's|^|'${ind}|g'
  echo -e "${CT0}${ind}Licence ${C0}${lic} ${p_dsc} ${p_vrs}"
}

get_longdesc(){
  if [ -n "${apt+x}" ];then
    echo -e $(apt-cache show ${apt} 2>/dev/null | \
      grep -E "Description-..^|^ " | \
      sed $'s/\*/\u2605/g' | \
      sed '/^ *This package contains.*\./d') | fold -s -w120 | sed 's/^/'"${ind}"'/g' 
  else
    echo "(Description not available)"
  fi
}

cmake_create_toolchain(){
  export cmake_toolchain_file=${1}
  cat <<-EOF >${cmake_toolchain_file}
set(CMAKE_SYSTEM_NAME ${host_platform})
set(CMAKE_SYSTEM_PROCESSOR ${host_abi})
set(CMAKE_SYSROOT ${host_sysroot})
set(CMAKE_FIND_ROOT_PATH ${host_sysroot} ${packages_dir})
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
set(CMAKE_C_COMPILER ${CC})
set(CMAKE_CXX_COMPILER ${CXX})
set(CMAKE_AR ${AR} CACHE FILEPATH Archiver)
set(CMAKE_RANLIB ${RANLIB} CACHE FILEPATH Indexer)
set(CMAKE_C_FLAGS ${CMAKE_C_FLAGS} ${CPPFLAGS} ${CFLAGS})
set(CMAKE_CXX_FLAGS ${CMAKE_C_FLAGS} ${CPPFLAGS} ${CXXFLAGS})
include(${packages_dir})
EOF
  case ${host_platform} in
    Android) cat <<-EOF >>${cmake_toolchain_file}
set(CMAKE_ANDROID_ARCH_ABI ${host_abi})
set(ANDROID_PLATFORM ${ndk_api})
set(ANDROID_NDK ${ANDROID_NDK_HOME})
set(CMAKE_FIND_ROOT_PATH ${host_sysroot}/usr ${host_sysroot}/usr/lib/$host_arch} ${host_sysroot}/usr/lib/${host_arch}/${ndk_api} ${packages_dir})
include(${ANDROID_NDK_HOME}/build/cmake/android.toolchain.cmake)
EOF
      ;;
    Windows) cat <<-EOF >>${cmake_toolchain_file}
set(CMAKE_RC_COMPILER ${host_cross_prefix}windres)
set(CMAKE_MC_COMPILER ${host_cross_prefix}windmc)
EOF
      ;;
  esac
}

#usage: meson_create_toolchain <out.meson.file>
meson_create_toolchain(){
  case ${host_arch} in
    aarch*)  cpu1="aarch64" cpu2="aarch64";;
    arm*)    cpu1="arm"     cpu2="arm";;
    i686*)   cpu1="x86"     cpu2="i686";;
    x86_64*) cpu1="x86_64"  cpu2="x86_64";;
  esac
  cmake_create_toolchain ${build_dir}
  cat <<-EOF >${1}
  [binaries]
  c = '${CC}'
  c_ld = '${LD}'
  cpp = '${CXX}'
  cpp_ld = '${LD}'
  ar = '${AR}'
  as = '${AS}'
  pkgconfig = 'pkg-config'
  addr2line = '${ADDR2LINE}'
  objcopy = '${OBJCOPY}'
  objdump = '${OBJDUMP}'
  ranlib = '${RANLIB}'
  readelf = '${READELF}'
  size = '${SIZE}'
  strings = '${STRINGS}'
  strip = '${STRIP}'
  windres = '${WINDRES}'

  [properties]
  needs_exe_wrapper = true
  cmake_toolchain_file = '${cmake_toolchain_file}'
  
  [host_machine]
  system = '$(str_lowercase ${PLATFORM})'
  cpu_family = '${cpu1}'
  endian = 'little'
  cpu = '${cpu2}'

  [target_machine]
  system = '$(str_lowercase ${PLATFORM})'
  cpu_family = '${cpu1}'
  endian = 'little'
  cpu = '${cpu2}'
	EOF
  echo "\nMeson file:(${1})\n\n" >>${logfile} 2>&1
  cat ${1} >>${logfile} 2>&1
}

setup_toolchain(){
  
  [ -z ${host_cross_cx+x} ] && host_cross_cx=${host_arch}
  [ -z ${host_cross_prefix+x} ] && host_cross_prefix=${host_arch}

  case ${host_platform} in
    Android)
      host_clang=true
      host_toolchain="${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin"
      host_sysroot="${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/sysroot"
      host_cross_cx="${host_toolchain}/${host_cross_cx}${ndk_api}-"
      host_cross_prefix="${host_toolchain}/${host_cross_prefix}-"
      CC="${host_cross_cx}clang"
      CXX="${host_cross_cx}clang++"
      AS="${CC}"
      LD="${host_toolchain}/ld.lld"
      CT0=$CG0 CT1=$CG1
      ;;
    Linux)
      host_clang=false
      host_toolchain="/usr/bin"
      host_sysroot="/usr/${arch}"
      host_cross_cx="${host_toolchain}/${host_cross_cx}-"
      host_cross_prefix="${host_toolchain}/${host_cross_prefix}-"
      CC="${host_cross_cx}gcc"
      CXX="${host_cross_cx}g++"
      AS="${host_cross_prefix}as"
      LD="${host_cross_prefix}ld"
      CT0=$CM0 CT1=$CM1
      ;;
    Windows)
      host_clang=true
      host_toolchain="${LLVM_MINGW_HOME}/bin"
      host_sysroot="${LLVM_MINGW_HOME}/${host_prefix}"
      host_cross_cx="${host_toolchain}/${host_cross_cx}-"
      host_cross_prefix="${host_toolchain}/${host_cross_prefix}-"
      CC="${host_cross_cx}clang"
      CXX="${host_cross_cx}clang++"
      AS="${host_cross_prefix}as"
      LD="${host_cross_prefix}ld"
      CT0=$CC0 CT1=$CC1
      ;;
  esac
  export host_arch host_abi host_platform host_clang \
    host_toolchain host_sysroot host_cross_prefix \
    host_cross_cx CC CXX AS LD \
    AR=${host_cross_prefix}ar
    NM=${host_cross_prefix}nm
    ADDR2LINE=${host_cross_prefix}addr2line \
    OBJCOPY=${host_cross_prefix}objcopy \
    OBJDUMP=${host_cross_prefix}objdump \
    RANLIB=${host_cross_prefix}ranlib \
    READELF=${host_cross_prefix}readelf \
    SIZE=${host_cross_prefix}size \
    STRINGS=${host_cross_prefix}strings \
    STRIP=${host_cross_prefix}strip \
    WINDRES=${host_cross_prefix}windres \
    install_dir="$(pwd)/builds/${host_platform,}/${host_abi}"
}

while [ -n "${1}" ];do
  case ${1} in
    aa64|aa8|a*64-*android|android )
      host_arch='aarch64-linux-android'
      host_abi='arm64-v8a'
      host_cross_prefix='llvm'
      host_platform="Android"
      setup_toolchain
      ;;
    aa7|arm-*android*eabi|arm-android)
      host_arch='arm-linux-androideabi'
      host_cross_cx='armv7a-linux-androideabi'
      host_cross_prefix='llvm'
      host_abi='armeabi-v7a'
      host_platform="Android" 
      setup_toolchain
      ;;
    a86|ax86|*86-*android)
      host_arch='i686-linux-androideabi'
      host_cross_prefix='llvm'
      host_abi='x86'
      host_platform="Android" 
      setup_toolchain
      ;;
    a64|ax64|*64-*android)
      host_arch='x86_64-linux-androideabi'
      host_cross_prefix='llvm'
      host_abi='x86_64'
      host_platform="Android"
      setup_toolchain
      ;;
    la8|la64|a*64-linux|a*64-*gnu|a*64-linux-gnu|rpi*64|rpi3b*)
      host_arch='aarch64-linux-gnu'
      host_abi='aarch64' 
      host_platform="Linux" 
      setup_toolchain
      ;;
    la7|lahf|arm*hf|arm-linux*|rpi*32|rpi2*)
      host_arch='arm-linux-gnueabihf'
      host_abi='arm'
      host_platform="Linux"
      setup_toolchain
      ;;
    l86|lx86|*86-linux*|linux*32)
      host_arch='i686-linux-gnu'
      host_abi='arm'
      host_platform="Linux"
      setup_toolchain
      ;;
    l64|lx64|*64-linux*|linux*64|linux )
      host_arch='i686-linux-gnu'
      host_abi='arm'
      host_platform="Linux"
      CT0=$CM0 CT1=$CM1
      ;;
    wa8|a*64-w64*|a*64-*mingw*)
      host_arch='aarch64-w64-mingw32'
      host_abi='aarch64'
      host_platform="Windows"
      setup_toolchain
      ;;
    wa7|arm*-w64*|arm*-*mingw*)
      host_arch='armv7-w64-mingw32'
      host_abi='armv7'
      host_platform="Windows"
      setup_toolchain
      ;;
    w86|wx86|*86-win*|*86-*mingw*|w*32)
      host_arch='i686-w64-mingw32'
      host_abi='x86'
      host_platform="Windows"
      setup_toolchain
      ;;
    w64|wx64|*64-win*|*64-*mingw*|windows|win|w*64)
      host_arch='x86_64-w64-mingw32'
      host_abi='x86_64'
      host_platform="Windows"
      setup_toolchain
      ;;

    --api)		shift; export host_api=$1;;
    --clang)	use_clang=true;;
    --prefix)	shift; packages_dir=$1;;
    --nodev)	req_src_nodev=true;;
    --clone)	req_src_clone=true;;
    --update)	req_src_update=true;;
    --redo)		shift; redo_action=${1};;
    --static)	build_static=true;;
    --shared)	build_shared=true;;
    --both)		build_shared=true build_static=true;;
    --bin)		build_bin=true;;
    --docs)		build_docs=true;;
    --check)  package_check_files; exit 0;;
    --get)		shift; case $1 in
      pc_cflags)		 [ -f "${pkgfile}" ] && echo $(pkg-config ${pkgfile} --cflags) && exit 0;;
      pc_libs)		   [ -f "${pkgfile}" ] && echo $(pkg-config ${pkgfile} --libs) && exit 0;;
      pc_staticlibs) [ -f "${pkgfile}" ] && echo $(pkg-config ${pkgfile} --libs --static) && exit 0;;
      pc-version)		 [ -f "${pkgfile}" ] && echo $(pkg-config ${pkgfile} --modversion) && exit 0;;
      pc-fpath)		   echo ${pkgfile} && exit 0;;
      pc_fname)		   echo ${pkg} && exit 0;;
      prefix)			   echo ${install_dir} && exit 0;;
      desc)			     echo ${dsc} && exit 0;;
      licence)		   echo ${lic} && exit 0;;
      libname)		   echo ${lib} && exit 0;;
      aptname)		   echo ${apt} && exit 0;;
      varname)		   shift; echo ${!1} && exit 0;;
      options)		   ;;
      esac
      ;;
    --clear) shift; case $1 in
      sources)	req_erase_list+=" ${pwd}/sources";;
      builds)		req_erase_list+=" ${pwd}/builds";;
      logs)		  req_erase_list+=" ${pwd}/builds/*.log";;
      source)		[ -n "${lib+x}" ] && req_erase_list+=" ${pwd}/sources/${lib}";;
      build)		[ -n "${lib+x}" ] && install_tree && req_erase_list+=" $(pwd)/builds/${host_os}/${host_abi}/${lib}";;
      pkgdist)	req_erase_list+=" ${pwd}/packages";;
      wipeall)	rm -rf sources builds packages 2>&1 >/dev/null && exit 0;;
      esac
      ;;
    *) break;;
  esac
  shift
done

if [ -n "${req_erase_list+x}" ];then
	for f in ${req_erase_list}; do
		rm_quiet $f
	done
  unset req_erase_list
fi

if [ -z ${lib+x} ];then
  echo -e "\n\n${ind}${CB1}${ind}Toolchain is loaded.\n${ind}Now exiting...\n\n${C0}"
  indent=0
  return 0
fi

! $build_static && ! $build_shared && build_static=true

[ -z ${packages_dir+x} ] && packages_dir="$(pwd)/builds/${host_platform,}/${host_abi}"

install_dir="${packages_dir}"
$install_tree && install_dir="${install_dir}/${lib}"

[ -z ${src+x} ] && err "No source defined. Exiting..."

[ ! -d "${install_dir}" ] && mkdir -p ${install_dir}

install_lib_dir="${install_dir}/lib"
install_inc_dir="${install_dir}/include"
install_pc_dir="${install_lib_dir}/pkgconfig"

export install_dir packages_dir install_lib_dir install_inc_dir install_pc_dir
       

