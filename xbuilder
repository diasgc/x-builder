#!$SHELL
# ................................................
# X-Builder util 0.3.2 2021-diasgc
# ................................................
[ -z ${vsh+x} ] && . .common

set -o pipefail

trap err ERR

# defvar debug=false
: "${debug:=false}"
: "${build_stable:=false}"
: "${is_init:=false}"
: "${pkg:=${lib}}"
: "${apt:=${lib}}"
: "${ac_nohost:=false}"
: "${disable_shared:=false}"
: "${ac_nosysroot:=false}"
: "${ac_nopic:=false}"
: "${banner:=true}"
: "${req_update_deps:=false}"
: "${update:=false}"
: "${build_dist:=true}"
: "${dep_build:=--static}"


$req_update_deps && update=true
clang_ld=lld
sudo=$(which sudo)
cmake_build_type=Release
cmake_toolchain_file=
mingw_posix_suffix=
update=false
retry=false
use_llvm_mingw=true
use_clang=true

# default build static, no shared, no executables
build_shared=false
build_static=true
build_bin=false
build_usepkgflags=false
git_stable=false
use_ndk_cmake=false

build_package=true
only_repo=false
pc_filelist=

shell_dstack=

# variables defined in .config file
# config_lastupdate
# ROOTDIR path
# build_arch (x86_64-linux-gnu)
# ANDROID_NDK_HOME path
# xv_ndk (23.1.7779620)
# xv_ndk_major (23)
# MAKE_EXECUTABLE path
# CMAKE_EXECUTABLE path
# NASM_EXECUTABLE path
# PKG_CONFIG path
# HOST_NPROC (4)
# LLVM_MINGW_HOME path
# LLVM_MINGW_REL (20211002)
# xv_llvm_mingw (13.0.0)
# llvm_mingw_rel (20211002)
# xv_aarch64_gnu (11)
# xv_armeabi_gnu (10)
# xv_x86_gnu (10)
# xv_x64_gnu (10)
# xv_x64_mingw (10)
# xv_x86_mingw="10"

init(){
  [ -f ".config" ] && . .config
  if [ ! -f ".config" ] || test `expr $(date +%s) - $config_lastupdate` -gt 86400; then
    ./xsetup.sh
    . .config || doErr 'Unable to initialize config file'
  fi
  [ -z "${indent}" ] && indent=0
  export is_init=true indent ind
}

! $is_init && init

inc_tab

main(){

  while [ -n "$1" ];do
    case $1 in
      --help|-h) showBanner; usage; exit 0;;
      --debug)   debug=true; set -x;;

      aa64|aa8|a*64-*android|android ) set_host 0; target_trip=('aarch64' '' 'linux' 'android' '');;
      aa7|arm-*android*eabi|arm-android) set_host 1; target_trip=('arm' 'v7a' 'linux' 'android' 'eabi');;
      a86|ax86|*86-*android) set_host 2; target_trip=('i686' '' 'linux' 'android' '');;
      a64|ax64|*64-*android) set_host 3; target_trip=('x86_64' '' 'linux' 'android' '');;
      la8|la64|a*64-linux|a*64-*gnu|a*64-linux-gnu|rpi*64|rpi3b*) set_host 4; target_trip=('aarch64' '' 'linux' 'gnu' '');;
      la7|lahf|arm*hf|arm-linux*|rpi*32|rpi2*) set_host 5; target_trip=('arm' '' 'linux' 'gnu' 'eabihf');;
      l86|lx86|*86-linux*|linux*32 ) set_host 6; target_trip=('i686' '' 'linux' 'gnu' '');;
      l64|lx64|*64-linux*|linux*64|linux ) set_host 7; target_trip=('x86_64' '' 'linux' 'gnu' '');;
      wa8|a*64-w64*|a*64-*mingw*) set_host 8; target_trip=('aarch64' '' 'w64' 'mingw32' '');;
      wa7|arm*-w64*|arm*-*mingw*) set_host 9; target_trip=('arm' 'v7' 'w64' 'mingw32' '');;
      w86|wx86|*86-win*|*86-*mingw*|w*32) set_host 10; target_trip=('i686' '' 'w64' 'mingw32' '');;
      w64|wx64|*64-win*|*64-*mingw*|windows|win|w*64) set_host 11; target_trip=('x86_64' '' 'w64' 'mingw32' '');;

      --full)     build_shared=true build_static=true build_bin=true build_dist=true;;
      --shared)   build_shared=true build_static=false;;
      --static)   build_static=true build_shared=false;;
      --both)     build_static=true build_shared=true;;
      --bin)      build_bin=true;;
      --nodist)   build_dist=false;;
      
      --api) shift && export API=$1;;
      --clang) use_clang=true;;
      --prefix) shift && LIBSDIR=$1;;
      --stable) git_stable=true;;
      
      --update-source|--update) req_build_id=0;;
      --update-setup) req_build_id=1;;
      --update-config) req_build_id=2;;
      --update-build) req_build_id=3;;
      --update-install) req_build_id=4;;
      --update_dist) req_build_id=5;;
      --update )  update=true;;
      --updateall )  update=true; req_update_deps=true;;
      --vrep)     git_remote_version $src && exit 0;;
      --opts)     showOpts "$(pwd)/sources/$lib" && exit 0;;
      --checkPkg) checkPkg && exit 0;;
      --libName)  echo $lib && exit 0;;
      --getVar)   shift && echo $($1) && exit 0;;
      --refresh)  update=true;;
      --retry)    retry=true;;
      --rebuild|--force) [ -f "$LIBSDIR/lib/pkgconfig/${pkg}.pc" ] && rm $LIBSDIR/lib/pkgconfig/${pkg}.pc;;
      --clear) shift
        while [ -n "$1" ];do
          case $1 in
            source|src) [ -n "${lib}" ] && rm -rf sources/${lib} 2>/dev/null;;
            all-sources) rm -rf sources 2>/dev/null;;
            all-builds) rm -rf builds 2>/dev/null;;
            all-packages) rm -rf packages 2>/dev/null;;
          esac
          shift
        done
        exit 0
        ;;
      --set) shift
        while [ $1 ]; do
          case $1 in
            cflags) set_pkgconfig_cflags;;
            ldflags) set_pkgconfig_ldflags;;
            ldstatic) set_pkgconfig_ldstatic;;
            --*) break;;
          esac
          shift
        done
        ;;
      --get) shift
        pkgfile="$LIBSDIR/lib/pkgconfig/${pkg}.pc"
        case $1 in
          cflags)     [ -f "${pkgfile}" ] && echo $(pkg-config ${pkgfile} --cflags) && exit 0;;
          ldflags)    [ -f "${pkgfile}" ] && echo $(pkg-config ${pkgfile} --libs) && exit 0;;
          ldstatic)   [ -f "${pkgfile}" ] && echo $(pkg-config ${pkgfile} --libs --static) && exit 0;;
          pc-ver)     [ -f "${pkgfile}" ] && echo $(pkg-config ${pkgfile} --modversion) && exit 0;;
          pc-path|pc) echo ${pkgfile} && exit 0;;
          pc-name)    echo ${pkg} && exit 0;;
          prefix)     echo $LIBSDIR && exit 0;;
          libname)    echo ${lib} && exit 0;;
          aptname)    echo ${apt} && exit 0;;
          var) shift; echo ${!1} && exit 0;;
          cmake_include)
            if [ -z "$cmake_path" ];then
              echo
            else
              echo "$LIBSDIR/$cmake_path"
            fi
            exit 0
            ;;
        esac
        ;;
      --clone) only_repo=true;;   
      --cmake) cfg='cm';;
      --ndkcmake) use_ndk_cmake=true;;
      --ccmake) cfg='ccm';;
      --nobanner) banner=false;;
      --stable) build_stable=true;;
      --vlatest) echo $(githubLatestTarGz) && exit 0;;
      --wipeall) read -p "Wipe all data? [y|N]" r
        case $r in y|Y) rm -rf builds sources
        esac && exit 0
        ;;
      * ) if [ "$(type -t extraOpts)" = 'function' ]; then
            extraOpts $1
          else
            showBanner
            usage
            echo -e "${ind}${CR0}Unknown option $1\n${C0}"
            exit 1
          fi
          ;;
    esac
    shift
  done

  # Set default Host
  [ -z "${arch}" ] && set_host 7

  [ -z ${mingw_posix} ] && mingw_posix=false

  if [ -z "$ISRUNNING" ]; then
    showBanner
    export ISRUNNING=1
  fi
  if [ -n "${sudo}" ] && ! ${sudo} -n true 2>/dev/null; then
    echo -ne "${ind}${CY1}sudo: "
    ${sudo} echo -ne "\r"
  fi

  if [ -z "${CBN}" ];then
    $build_bin && CBN="${cb1}" || CBN="${cb0}"
  fi

  export arch update retry \
    build_shared build_static build_bin build_tool \
    CSH CBN LIBSDIR PLATFORM CPU ABI EABI \
    host_arch host_64 host_eabi host_vnd host_arm host_os \
    mingw_posix MAKE_EXECUTABLE=make cmake_includes


  $debug && set -x
  # exit if missing vars lib arch or src
  test -z ${lib} && {
    echo -e "\n\n${ind}${CB1}${ind}Toolchain is loadad.\n${ind}Now exiting...\n\n${C0}"
    indent=0
    return 0
  }

  test -z $LIBSDIR || test -z $src && errCall

  #[ -z "${cmake_toolchain_file}" ] && 
  logtime_start=0
  logtime_end=0

  PKGDIST="${ROOTDIR}/dist/${lib}"
  INSTALL_DIR=$LIBSDIR

  SOURCES=$ROOTDIR/sources
  SRCDIR=$SOURCES/$lib
  PKGDIR=$INSTALL_DIR/lib/pkgconfig
  
  export PKGDIST LIBSDIR SOURCES SRCDIR INSTALL_DIR PKGDIR
  [ -d "${SOURCES}" ] || mkdir -p ${SOURCES}

  gitjson=$(git_api_tojson $src)
  if [ -n "${gitjson}" ];then
    #echo -ne "${CY1}${b}${C0}"
    [ -z "${lic}" ] && lic=$(echo "$gitjson" | jq .licence)
    [ -z "${dsc}" ] && dsc=$(echo "$gitjson" | jq .description)
  fi
  # show package info
  [ -f "${PKGDIR}/${pkg}.pc" ] || show_pkginfo

  LOGFILE=$LIBSDIR/${lib}.log
}

load_target(){
  if [ "${build_trip}" == "${target_trip[0]}${target_trip[1]}-${target_trip[2]}-${target_trip[3]}${target_trip[4]}" ]; then
    SYSROOT= ; CROSS_PREFIX='llvm-'; CC=clang; CXX=clang++; AS=clang; LD="ld.${clang_ld}"
    host_cross=false
  else
    host_cross=true
    case ${target_trip[3]} in
      android)
        SYSROOT="${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/sysroot"
        ISYS=("${SYSROOT}/usr/include/${target_trip[0]}-${target_trip[2]}-${target_trip[3]}${target_trip[4]}")
        LSYS=("${SYSROOT}/usr/lib/${target_trip[0]}-${target_trip[2]}-${target_trip[3]}${target_trip[4]}" "${SYSROOT}/usr/lib/${target_trip[0]}-${target_trip[2]}-${target_trip[3]}${target_trip[4]}/${API})")
        CROSS_PREFIX="${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/"
        CC="${CROSS_PREFIX}${target_trip[0]}${target_trip[1]}-${target_trip[2]}-${target_trip[3]}${target_trip[4]}${API}-clang"
        CXX="${CC}++"; AS=${CC}; LD="${CROSS_PREFIX}ld.${clang_ld}"
        CROSS_PREFIX+="llvm-"
        ;;
      gnu)
      mingw32)
    esac
  fi

}

set_host(){
  cpu_id=$1
  host_cross=true
  host_clang=true
  host_arm=false; host_arm32=false; host_arm64=false
  host_x86=false; host_x64=false; host_ndk=false
  host_gnu=false; host_mingw=false
  os_id=$(expr $cpu_id / 4)
  p_id=$(expr $cpu_id % 4)
  unset LIBS CPPFLAGS CFLAGS CXXFLAGS LDFLAGS
  case $cpu_id in
    0)  toolchain_llvm_android 'aarch64' 'arm64-v8a';;
    1)  toolchain_llvm_android 'arm' 'armeabi-v7a' 'androideabi';;
    2)  toolchain_llvm_android 'i686' 'x86';;
    3)  toolchain_llvm_android 'x86_64' 'x86_64';;
    4)  toolchain_gcc_linux 'aarch64' 'aarch64';;
    5)  toolchain_gcc_linux 'arm' 'armeabihf' 'gnueabihf';;
    6)  toolchain_gcc_linux 'i686' 'i686';;
    7)  toolchain_gcc_linux 'x86_64' 'x86_64';;
    8)  $use_clang && toolchain_llvm_mingw 'aarch64' || toolchain_gcc_mingw 'aarch64';;
    9)  $use_clang && toolchain_llvm_mingw 'armv7' || toolchain_gcc_mingw 'armv7';;
    10) $use_clang && toolchain_llvm_mingw 'i686' || toolchain_gcc_mingw 'i686';;
    11) $use_clang && toolchain_llvm_mingw 'x86_64' || toolchain_gcc_mingw 'x86_64';;
  esac

  export cpu_id os_id p_id \
    host_arm host_arm32 host_arm64 host_x86 host_x64 \
    host_clang host_abi host_ndk host_gnu host_mingw
}

toolchain_llvm_android(){
  host_abi="${2}" host_os="android" host_sys="linux" host_ndk=true
  local tcabi="android"
  [ -n "${3}" ] && tcabi=${3}
  arch="${1}-${host_sys}-${tcabi}" 
  [ -z "$API" ] && API=24
  [ "$p_id" -lt 2 ] && CT0=$CG2 CT1=$CG5 || CT0=$CG0 CT1=$CG1
  PLATFORM="Android"
  CMAKE_TOOLCHAIN="${ANDROID_NDK_HOME}/build/cmake/android.toolchain.cmake"
  TOOLCHAIN="${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64"
  SYSROOT="${TOOLCHAIN}/sysroot"
  CROSS_PREFIX="${TOOLCHAIN}/bin/${arch}-"
  $host_arm32 && CC="${TOOLCHAIN}/bin/armv7a-linux-androideabi${API}-clang" || CC="${TOOLCHAIN}/bin/${arch}${API}-clang"
  CXX="${CC}++"
  AS="${CC}" #AS see https://developer.android.com/ndk/guides/other_build_systems
  LD="${TOOLCHAIN}/bin/ld.${clang_ld}" 
  GCOV="${TOOLCHAIN}/bin/llvm-cov"
  [ ! -f "${CROSS_PREFIX}ar" ] && CROSS_PREFIX="${TOOLCHAIN}/bin/llvm-"
  YASM=${TOOLCHAIN}/bin/yasm
  LT_SYS_LIBRARY_PATH="$SYSROOT/usr/lib/$arch:$SYSROOT/usr/lib/${arch}/${API}"
  LDFLAGS="-Wl,-rpath,${LT_SYS_LIBRARY_PATH} ${LDFLAGS}"
  CPPFLAGS="-I${SYSROOT}/usr/include/${arch}"
  ${use_ndk_cmake} && [ -d "${ANDROID_HOME}/cmake" ] && CMAKE_EXECUTABLE="${ANDROID_HOME}/cmake/3.10.2.4988404/bin/cmake"
  toolchain_common
}

toolchain_gcc_linux(){
  host_clang=false
  PLATFORM="Linux"
  host_abi="${2}" host_os='linux' host_sys='linux' host_gnu=true
  local tcabi="gnu"
  [ -n "${3}" ] && local tcabi=${3}
  arch="${1}-linux-${tcabi}"
  [ "$p_id" -lt 2 ] && CT0=$CY0 CT1=$CY1 || CT0=$CM0 CT1=$CM1
  local ltsdir=("$xv_aarch64_gnu" "$xv_armeabi_gnu" "$xv_x86_gnu" "$xv_x64_gnu")
  ltsdir=${ltsdir[$(expr $cpu_id % 4)]}
  if $host_cross; then
    SYSROOT="/usr/${arch}"
    TOOLCHAIN="/usr/${arch}/bin"
    CROSS_PREFIX="${arch}-"
    local cross="-cross"
  else
    unset SYSROOT TOOLCHAIN CROSS_PREFIX
  fi
  CC=${CROSS_PREFIX}gcc
  CXX=${CROSS_PREFIX}g++
  AS=${CROSS_PREFIX}as
  LD=${CROSS_PREFIX}ld
  
  [ -n "$ltsdir" ] && LT_SYS_LIBRARY_PATH="/usr/lib/gcc${cross}/${arch}/${ltsdir}"
  LDFLAGS="-Wl,-rpath,${LT_SYS_LIBRARY_PATH} ${LDFLAGS}"
  CPPFLAGS=" -I$SYSROOT/usr/include -I$SYSROOT/usr/local/include -I$LIBSDIR/include"
  toolchain_common
}

toolchain_llvm_mingw(){
  PLATFORM="Windows"
  host_os='windows' host_sys='windows' host_mingw=true
  [ -z ${2} ] && host_abi="${1}" || host_abi="${2}"
  arch="${1}-w64-mingw32"
  [ "$p_id" -lt 2 ] && CT0=$CC0 CT1=$CC1 || CT0=$CB0 CT1=$CB1
  TOOLCHAIN="${LLVM_MINGW_HOME}/bin"
  SYSROOT="${LLVM_MINGW_HOME}/${arch}"
  CROSS_PREFIX="${TOOLCHAIN}/${arch}-"
  
  CC="${CROSS_PREFIX}clang"
  CXX="${CC}++"
  LD="${CROSS_PREFIX}ld"
  AS="${CROSS_PREFIX}as"
  RC="${CROSS_PREFIX}windres"

  LT_SYS_LIBRARY_PATH="${LLVM_MINGW_HOME}/lib/clang/${xv_llvm_mingw}"
  CPPFLAGS="-I$LT_SYS_LIBRARY_PATH/include"
  LDFLAGS="-L${LT_SYS_LIBRARY_PATH}/lib -L${SYSROOT}/lib"
  toolchain_common
}

toolchain_gcc_mingw(){
  PLATFORM="Windows"
  host_os='windows' host_sys='windows' host_mingw=true
  [ "$p_id" -lt 2 ] && CT0=$CC0 CT1=$CC1 || CT0=$CB0 CT1=$CB1
  [ -z ${2} ] && host_abi="${1}" || host_abi="${2}"
  arch="${1}-w64-mingw32"
  [ "$p_id" -lt 2 ] && CT0=$CM2 CT1=$CM5 || CT0=$CM0 CT1=$CM1
  CROSS_PREFIX="${arch}-"
  TOOLCHAIN="/usr/${arch}/bin"
  SYSROOT="/usr/${arch}"
  CC="${CROSS_PREFIX}gcc"
  CXX="${CROSS_PREFIX}g++"
  $mingw_posix && CC+="-posix" && CXX+="-posix"
  LD="${CROSS_PREFIX}ld"
  AS="${CROSS_PREFIX}as"
  RC="${CROSS_PREFIX}windres"
  LT_SYS_LIBRARY_PATH="/usr/lib/gcc/${arch}/${xv_x64_mingw}"
  LDFLAGS="-L${LT_SYS_LIBRARY_PATH}"
  CPPFLAGS=" -I$SYSROOT/usr/include -I$SYSROOT/usr/local/include -I$LIBSDIR/include"
  toolchain_common
}

toolchain_common(){
  case $p_id in
    0) host_arm=true host_arm64=true;;
    1) host_arm=true host_arm32=true;;
    2) host_x86=true;;
    3) host_x64=true;;
  esac
  
  AR=${CROSS_PREFIX}ar
  NM=${CROSS_PREFIX}nm

  ADDR2LINE=${CROSS_PREFIX}addr2line
  OBJCOPY=${CROSS_PREFIX}objcopy
  OBJDUMP=${CROSS_PREFIX}objdump
  RANLIB=${CROSS_PREFIX}ranlib
  READELF=${CROSS_PREFIX}readelf
  SIZE=${CROSS_PREFIX}size
  STRINGS=${CROSS_PREFIX}strings
  STRIP=${CROSS_PREFIX}strip
  WINDRES=${CROSS_PREFIX}windres
  [ -z ${GCOV+x} ] && GCOV=${CROSS_PREFIX}gcov

  #reset flags
  LIBSDIR="$(pwd)/builds/${host_os}/${host_abi}"
  LDFLAGS+=" -L$LIBSDIR/lib"
  
  [ "$arch" == "$build_arch" ] && host_cross=false
  
  # export
  export CMAKE_EXECUTABLE YASM PKG_CONFIG API \
    PLATFORM TOOLCHAIN SYSROOT CC CXX LD AS \
    ADDR2LINE AR NM OBJCOPY OBJDUMP RANLIB \
    READELF SIZE STRINGS STRIP WINDRES \
    CROSS_PREFIX LT_SYS_LIBRARY_PATH CPPFLAGS LDFLAGS
}

cmake_toolchain_create(){
  cmake_toolchain_file="$BUILD_DIR/xbuilder.cmake"
  local proc=('aarch64' 'arm' 'i686' 'x86_64')
  $host_ndk && proc[1]='armv7-a'
  local abi=('arm64-v8a' 'armeabi-v7a' 'x86' 'x86_64')
  local rpath=$(echo "${SYSROOT}/usr ${LT_SYS_LIBRARY_PATH} ${LIBSDIR}" | sed 's/:/ /g')
  cat <<-EOF >${cmake_toolchain_file}
		set(CMAKE_SYSTEM_NAME "${host_os^}")
		set(CMAKE_SYSTEM_PROCESSOR "${proc[$p_id]}")
    set(CMAKE_C_COMPILER ${CC})
    set(CMAKE_CXX_COMPILER ${CXX})
    set(CMAKE_AR ${AR} CACHE FILEPATH Archiver)
    set(CMAKE_RANLIB ${RANLIV} CACHE FILEPATH Indexer)
		set(CMAKE_C_FLAGS "${CPPFLAGS} ${CFLAGS} ${CMAKE_C_FLAGS}")
    set(CMAKE_CXX_FLAGS "${CPPFLAGS} ${CXXFLAGS} ${CMAKE_CXX_FLAGS}")
    set(CMAKE_EXE_LINKER_FLAGS "${LDFLAGS} ${CMAKE_EXE_LINKER_FLAGS}")
    set(CMAKE_FIND_ROOT_PATH ${rpath})
		EOF
  $host_x86 && cat <<-EOF >>${cmake_toolchain_file}
		set(CMAKE_C_COMPILER_ARG1 "-m32")
		set(CMAKE_CXX_COMPILER_ARG1 "-m32")
		EOF
  $host_mingw && cat <<-EOF >>${cmake_toolchain_file}
		set(CMAKE_COMPILER_IS_MINGW ON)  
		set(CMAKE_RC_COMPILER ${WINDRES})
		set(CMAKE_MC_COMPILER ${CROSS_PREFIX}windmc)
		set(CMAKE_CXX_STANDARD_LIBRARIES "-static-libgcc -static-libstdc++ -lwsock32 -lws2_32 ${CMAKE_CXX_STANDARD_LIBRARIES}")
		set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -Wl,-Bstatic")
		set(CMAKE_FIND_LIBRARY_PREFIXES "lib" "")
		set(CMAKE_FIND_LIBRARY_SUFFIXES ".dll" ".dll.a" ".lib" ".a")
		EOF
  $host_ndk && cat <<-EOF >>${cmake_toolchain_file}
		set(ANDROID_ABI ${abi[$p_id]})
		set(ANDROID_PLATFORM ${API})
		set(ANDROID_NDK ${ANDROID_NDK_HOME})
		set(ZLIB_INCLUDE_DIRS ${SYSROOT}/usr/include)
		set(ZLIB_LIBRARIES ${SYSROOT}/usr/lib/${arch})
		set(ZLIB_VERSION_STRING 1.2.11)
		include(${ANDROID_NDK_HOME}/build/cmake/android.toolchain.cmake)
		EOF
}

show_pkginfo(){
  local DP=
  local VS=
  local longdesc
  [ -n "$apt" ] && longdesc=$(echo -e $(apt-cache show ${apt} 2>/dev/null | \
    grep -E "Description-..^|^ " | \
    sed $'s/\*/\u2605/g' | \
    sed '/^ *This package contains.*\./d') | fold -s -w120 | sed 's/^/'"${ind}"'/g')
  [ -z "$(echo $longdesc | xargs 2>/dev/null)" ] && unset longdesc
  [ -n "${tls}" ] && DP="${CT0}build deps: ${C0}$tls "
  [ -n "${dep}" ] && DP="${DP}${CT0}lib deps: ${C0}$dep"
  if [ "$sty" == "git" ];then
    local vgit=$(git_remote_version $src)
    if [ -d $SRCDIR ];then
      pushdir $SRCDIR
      local vrep=$(git describe --abbrev=0 --tags 2>/dev/null)
      popdir
      VS="${CT0}vrs: ${C0}$vrep "
      str_contains $vgit $vrs && \
        pushvar_l VS 'updated' || \
        pushvar_l VS "$VS ${CT0}latest: ${CT1}${vgit}${C0}"
    else
      VS="${CT0}vrs: ${C0}${vgit}"
    fi
  fi
  [ -n "${dsc}" ] && echo -e "\n${CW}${ind}${lib^^} - ${C0}${dsc}"
  [ -n "${longdesc}" ] && echo -e "${CD}${longdesc}" | sed 's|\*|\u2605|g; s|\..\..|. |g' # sed 's|^|'${ind}|g'
  echo -e "${CT0}${ind}Licence ${C0}$lic ${DP} ${VS}"
}

setup_buildtool(){
  if [ -n "${cfg}" ]; then
    case ${cfg} in
      cm|ccm|cmake|ccmake) build_tool=cmake;;
      ab) build_tool=automake;;
      ac|ar|ag) build_tool=automake;;
      am|auto|automake|gnu) unset cfg;;
      meson) build_tool=meson;;
      make|mk) build_tool=make;;
    esac
  fi

  if [ -z "${cfg}" ]; then
    if [ -f "${CONFIG_DIR}/CMakeLists.txt" ]; then
      build_tool="cmake"
      cfg="cmake"
    elif [ -f "${CONFIG_DIR}/autogen.sh" ]; then
      build_tool="automake"
      cfg="ac"
      automake_cmd="${CONFIG_DIR}/autogen.sh"
    elif [ -f "${CONFIG_DIR}/bootstrap.sh" ]; then
      build_tool="automake"
      cfg="ac"
      automake_cmd="${CONFIG_DIR}/bootstrap.sh"
    elif [ -f "${CONFIG_DIR}/bootstrap" ]; then
      build_tool="automake"
      cfg="ac"
      automake_cmd="${CONFIG_DIR}/bootstrap"
    elif [ -f "${CONFIG_DIR}/configure.ac" ] || [ -f "${CONFIG_DIR}/configure.in" ]; then
      build_tool="automake"
      cfg="ar"
    elif [ -f "${CONFIG_DIR}/meson.build" ]; then
      build_tool="meson"
      cfg="meson"
    else
      return 1
    fi
  fi

  case $build_tool in
    cmake) 
      [ -n "$cstk" ] && cst0="-D${cstk}=OFF" cst1="-D${cstk}=ON"
      [ -n "$cshk" ] && csh0="-D${cshk}=OFF" csh1="-D${cshk}=ON"
      
      [ -z "$cst1" ] && cst1="-DBUILD_SHARED_LIBS=OFF"
      [ -z "$csh1" ] && csh1="-DBUILD_SHARED_LIBS=ON"
      
      $build_static && ! $build_shared && CSH="${cst1} ${csh0}"
      $build_shared && ! $build_static && CSH="${csh1} ${cst0}"
      $build_static && $build_shared && CSH="${cst1} ${csh1}"
      
      [ -n "$cbk" ] && cb0="-D${cbk}=OFF" cb1="-D${cbk}=ON"
      ;;
    automake)
      [ -z "$cst0" ] && cst0="--disable-static"
      [ -z "$cst1" ] && cst1="--enable-static"
      [ -z "$csh0" ] && csh0="--disable-shared"
      [ -z "$csh1" ] && csh0="--enable-shared"
      $build_static && ! $build_shared && CSH="${cst1} ${csh0}"
      $build_shared && ! $build_static && CSH="${csh1} ${cst0}"
      $build_static && $build_shared && CSH="${cst1} ${csh1}"
      [ -n "$cbk" ] && {
        case $cbk in
          --enable-*) cb0="${cbk}=0"; cb1="${cbk}=1";;
          able-*) cb0="--dis${cbk}"; cb1="--en${cbk}";;
          with-*) cb0="--without-${cbk:5}"; cb1="--${cbk}";;
          *) cb0="--enable-${cbk}=0" cb1="--enable-${cbk}=1";;
        esac
      }
      ;;
    meson)
      build_tool=meson
      $build_static && ! $build_shared && CSH="-Ddefault_library=static"
      $build_shared && ! $build_static && CSH="-Ddefault_library=shared"
      $build_static && $build_shared && CSH="-Ddefault_library=both"
      ;;
    *) unset build_tool;;
  esac

  return 0
}

config_buildtool(){

  local od=$(pwd)
  cd $CONFIG_DIR
  export NOCONFIGURE=1
  if [ -n "${automake_cmd}" ]; then
    doLog 'config' ${automake_cmd}
  elif [ "${cfg}" == "ar" ]; then
    doLog 'autoreconf' autoreconf -fi
  elif [ "${cfg}" == "ag" ]; then
    doLog 'autogen' ./autogen.sh
  fi
  cd $od
  return 0
}

get_source(){
  if [ -z "${sty}" ];then
    case $src in
      *.tar*) sty="tar";;
      *git.*|*.git) sty="git";;
      *svn.*) sty="svn";;
      *hg.*) sty="hg";;
      *) doErr "unkown source type for $src";;
    esac
  fi
  case $sty in
    git) git_clone $src $lib;;
    tar|tgz|txz|tlz) wget_tarxx $src $lib;;
    svn) do_svn $src $lib;;
    hg) do_hg $src $lib;;
    *) doErr "unknown source type '$sty' for $src";;
  esac
}

# Variables
# mki: rule for install 'make $mkinstall' (default: install)
# mkc: rule for clean 'make $mkclean' (default: clean)
# mkf: additional rule for make
# no_host  : while using autotools, no host will be set for cross-compile if no_host is not empty

gitjson=

start(){
  
  # check whether to update source of main lib and dependencies
  if [ "$req_build_id" == "0" ]; then
    rm -rf "${SOURCES}/${lib}"
    ! $req_update_deps && update=false
  else
    [ -f "${PKGDIR}/${pkg}.pc" ] && exit
  fi
  
  # Reset LOGFILE
  [ -f "${LOGFILE}" ] && rm -f $LOGFILE

  # Create INSTALL_DIR and PKGCONFIG DIR
  mkdir -p $PKGDIR
  export PKG_CONFIG_LIBDIR="$PKGDIR:$PKG_CONFIG_LIBDIR"

  check_tools $tls
  build_dependencies $dep

  log_start $arch ${eta}s
  local bss=
  $build_static && bss="${SSB}[static]" || bss="${CD}[static]"
  $build_shared && bss="${bss}${SSB}[shared]" || bss="${bss}${CD}[shared]"
  $build_bin && echo -ne "${bss}${SSB}[bin]${C0} " || echo -ne "${bss}${CD}[bin]${C0} "
  cd $SOURCES

  ! $retry && [ "${BUILD_DIR}" != "$SRCDIR" ] && rm -rf ${BUILD_DIR}
  
  # use this instead
  [ -n "${dir_config+x}" ] && CONFIG_DIR="${SOURCES}/${lib}/${dir_config}" || CONFIG_DIR=${SRCDIR}

  # get source
  local request_config=false
  
  if [ ! -d $SRCDIR ];then
    # check whether to custom or default get source
    ifdef_function 'source_get' && source_get || get_source
    # request config after get source
    request_config=true
  fi

  [ "$req_build_id" == "1" ] && request_config=true
  setup_buildtool
  cd $CONFIG_DIR


  # config source for 1st time
  if $request_config; then
    [ -n "${src_cfg}" ] && eval ${src_cfg} >>$LOGFILE 2>&1 || {
      # check whether to custom config source
      ifdef_function 'source_config' && doLog 'config' source_config || config_buildtool
    }
    [ -n "${src_patch}" ] && eval ${src_patch} >>$LOGFILE 2>&1 || {
      # check whether to custom patch source
      ifdef_function 'source_patch' && doLog 'patch' source_patch
    }
    # check whether to auto patch source
    check_xbautopatch
  fi

  $only_repo && end_script

  if [ -z "$BUILD_DIR" ];then
    case $build_tool in
      cmake|meson) BUILD_DIR="${CONFIG_DIR}/build_${arch}"
        [ -d "${BUILD_DIR}" ] && rm -rf ${BUILD_DIR}
        mkdir -p ${BUILD_DIR}
        ;;
      *) BUILD_DIR=${CONFIG_DIR};;
    esac
  fi
  
  cd ${BUILD_DIR}

  log_vars SRCDIR CONFIG_DIR BUILD_DIR dep PKG_CONFIG_LIBDIR
  log_vars CC CXX LD AS AR NM RANLIB STRIP
  
  ifdef_function 'build_all' && {
    build_all
    end_script
  }

  ifdef_function 'build_prepare' && build_prepare

  ifdef_function 'build_clean' && build_clean || {
    [ -z "$mkc" ] && mkc="clean"
    [ -f "Makefile" ] && doNoLog 'clean' ${MAKE_EXECUTABLE} $mkc
  }

  MAKE_EXECUTABLE=make
  if ifdef_function 'build_config'; then
    build_config
  else
    case $build_tool in
      cmake)
        [ -z "$exec_config" ] && exec_config=${CMAKE_EXECUTABLE}
        [ -z "$cmake_toolchain_file" ] && cmake_create_toolchain ${BUILD_DIR}
        [ -f "$cmake_toolchain_file" ] && CFG="-DCMAKE_TOOLCHAIN_FILE=${cmake_toolchain_file} $CFG"
        doLog 'cmake' $exec_config ${CONFIG_DIR} -DCMAKE_INSTALL_PREFIX=${INSTALL_DIR} -DCMAKE_BUILD_TYPE=$cmake_build_type ${CFG} ${CSH} ${CBN}
        case $cfg in ccm|ccmake) tput sc; ccmake ..; tput rc;; esac        
        ;;
      automake)
        [ -z "${mki+x}" ] && mki=$(make_findtarget "install-strip" "install")
        [ -z "${mkc+x}" ] && mkc=$(make_findtarget "distclean" "clean")
        [ -z "$exec_config" ] && exec_config='configure' # default config executable
        ! $ac_nohost && [ "$arch" != "${build_arch}" ] && CFG+=" --host=${arch}"
        ! $ac_nosysroot && CFG+=" --with-sysroot=${SYSROOT}"
        ! $ac_nopic && CFG+=" --with-pic=1"
        doLog 'configure' ${CONFIG_DIR}/${exec_config} --prefix=${INSTALL_DIR} $CFG $CSH $CBN
        ;;
      meson)
        local MESON_EXEC=$(check_tool_dependency meson)
        [ -z "$MESON_EXEC" ] && doErr 'Could not install meson. Aborting.'
        local MESON_CFG="$SRCDIR/${arch}.meson"
        [ -f "$MESON_CFG" ] && rm $MESON_CFG
        $host_clang || LD="bfd"
        meson_create_toolchain $MESON_CFG
        MAKE_EXECUTABLE=ninja
        doLog 'meson' ${MESON_EXEC} setup --buildtype=release --cross-file=${MESON_CFG} --prefix=${INSTALL_DIR} $CFG $CSH $CBN
        ;;
      make)
        mkf=$CFG
        ;;
      *)
        doErr "No cfg found or unknown for $cfg. Use build_config to custom configure makefile"
        ;;
    esac
  fi

  ifdef_function 'build_patch_config' && doLog 'patch' build_patch_config

  [ -n "${WFLAGS}" ] && CPPFLAGS+=" ${WFLAGS}"
  $build_static && LDFLAGS="-all-static $LDFLAGS"
  
  # set -all-static flags at make time (see: https://stackoverflow.com/questions/20068947/how-to-static-link-linux-software-that-uses-configure)
  # $build_static && [[ "$LDFLAGS" != *"-all-static"* ]] && LDFLAGS="-all-static $LDFLAGS"

  log_vars CFLAGS CXXFLAGS CPPFLAGS LDFLAGS LIBS

  ifdef_function 'build_make' && doLog 'make' build_make || doLogP 'make' ${MAKE_EXECUTABLE} $mkf -j${HOST_NPROC} || err

  ifdef_function 'patch_install' && patch_install

  [ -z "${mki}" ] && mki="install"
  ifdef_function 'build_install' && doLog 'install' build_install || doLog 'install' ${MAKE_EXECUTABLE} ${mki}

  # check whether to create pkg-config .pc file
  if [ -n "${req_pcforlibs+x}" ];then
    local pcf
    for l in $req_pcforlibs; do
      pcf=$(echo $l | sed 's|^lib||')
      create_pkgconfig_file $pcf "-l$pcf"
    done
  else
    ifdef_function 'build_pkgconfig_file' && \
    doLog 'pkgcfg' build_pkgconfig_file || \
    [ -n "$pc_llib" ] && \
    doLog 'write_pc' create_pkgconfig_file $pkg $pc_llib
  fi

  # create package
  $build_package && doLog 'tar' build_packages_bin

  popdir

  logver "$PKGDIR/${pkg}.pc"

  ifdef_function 'on_end' && on_end

  #stat_savestats
  end_script
}

# make_findtarget <find> <default>, returns 'find' if exists, otherwise 'default'
make_findtarget(){
  ${MAKE_EXECUTABLE} ${1} -n 2>>$LOGFILE
  test $? -eq 2 && {
    echo "${2}"; echo "make: target ${1} not found, setting default ${2} target." >>$LOGFILE
  } || {
    echo "${2}"; echo "make: target ${1} found." >>$LOGFILE
  }
}

end_script(){
  log_end
  # check if parent process is shell script
  local parent=$(ps -o comm= $PPID)
  [ "${parent: -3}" == ".sh" ] || echo -e "\n${ind}${CT1}::Done${C0}\n"
  $debug && set +x
  unset cst0 cst1 csh0 csh1 cb0 cb1 cstk cshk cbk \
    CONFIG_DIR CSH CBN exec_config vrs \
    ac_nohost ac_nopic ac_nosysroot req_pcforlibs \
    mkc mki WFLAGS
  dec_tab
  echo
  exit 0
}

check_xbautopatch(){
  local block
  local match
  if [ -n "${patch}" ]; then
    block=$(echo "$patch" | base64 -d)
    match="XB_APPLY_PATCH"
  else
    cd $ROOTDIR
    match=$(grep -oP "(?<=^<<').*?(?=')" $0)
    [ -z "$match" ] && return 0
    block=$(awk '/^<<.'"$match"'./{flag=1; next} /^'"$match"'/{flag=0} flag' $0)
  fi
  cd $SRCDIR
  echo -e "\npatch this: \n$block" >>$LOGFILE
  case $match in
    XB_CREATE_CMAKELISTS) echo "${block}" >CMakeLists.txt;;
    XB_APPLY_PATCH) patch -p0 <<<$(echo "${block}") 2>&1 >$LOGFILE;;
  esac
}

# usage create_pkgconfig_file <pkg>.pc [llibds][INSTALL_DIR]
create_pkgconfig_file(){
    [ -z "${1}" ] && pc_file=${lib} || pc_file=${1}
    [ -z "${2}" ] && pc_llib="-l${pc_file}" || pc_llib=${2}
    [ -z "${3}" ] && pc_prefix=${INSTALL_DIR} || pc_prefix=${3}

    [ -z "$pc_libdir" ] && pc_libdir="/lib"
    [ -z "$pc_incdir" ] && pc_incdir="/include"
    [ -z "$pc_cflags" ] && pc_cflags="-I\${includedir}"
    [ -z "$pc_libs" ] && pc_libs="-L\${libdir}"
    [ -z "$pc_url" ] && pc_url=$(dirname $src)
    [ -z "$pc_vrs" ] && {
      [ -d "${SRCDIR}/.git" ] && pc_vrs=$(git_getversion ${SRCDIR}) || pc_vrs=$vrs
    }
    cat <<-EOF >$PKGDIR/${pc_file}.pc
		prefix=${pc_prefix}
		exec_prefix=\${prefix}
		libdir=\${exec_prefix}${pc_libdir}
		includedir=\${prefix}${pc_incdir}

		Name: ${lib}
		Description: ${dsc}
		URL: ${pc_url}
		Version: ${pc_vrs}
		Requires: ${pc_requires}
		Requires.private: ${pc_requiresprivate}
		Libs: ${pc_libs} ${pc_llib}
		Libs.private: ${pc_libsprivate}
		Cflags: ${pc_cflags}
  
		EOF
    pc_filelist="${pc_file}.pc ${pc_filelist}"
    unset pc_libdir pc_incdir pc_cflags pc_libs pc_url
}

build_packages_getdistdir(){
  [ -f "$PKGDIR/${pkg}.pc" ] && vrs=$(pkg-config $PKGDIR/${pkg}.pc --modversion)
  [ -z "$vrs" ] && set_git_version
  echo "${ROOTDIR}/packages/${lib}-${vrs}-${arch}"
}

build_packages_filelist(){
  local scfile="${ROOTDIR}/${lib}.sh"
  if [ -z "$(cat $scfile | grep '# Filelist')" ]; then
    echo -e "\n\n# Filelist\n# --------" >> $scfile
    find ./ -type f | sed 's|^./|# |g' >> $scfile
  fi
}

build_packages_bin(){
  local xb_distdir=$(build_packages_getdistdir)
  if [ "$(type -t create_package)" = 'function' ]; then
    create_package $xb_distdir
  else
    if [ "$(type -t build_make_package)" = 'function' ]; then
      build_make_package $xb_distdir
    elif [ "$MAKE_EXECUTABLE" = "ninja" ];then
      DESTDIR=${xb_distdir} ninja -C ${BUILD_DIR} install
    else
      [ -z "$mkd" ] && mkd="DESTDIR=${xb_distdir} install"
      ${MAKE_EXECUTABLE} $mkd
    fi
    [ -z "$mkd_suffix" ] && mkd_suffix=${LIBSDIR}
    pushdir "${xb_distdir}${mkd_suffix}"
    
    # also include .pc manually-built file
    if [ "$(type -t build_pkgconfig_file)" = 'function' ] || [ -n "$pc_llib" ];then
      local xb_pkgd=$(pwd)/lib/pkgconfig
      [ ! -d "${xb_pkgd}" ] && mkdir -p $xb_pkgd
      if [ -n "${pc_filelist}" ];then
        for pp in ${pc_filelist}; do
          cp $PKGDIR/${pp} ${xb_pkgd}/
        done
      else
        cp $PKGDIR/${pkg}.pc ${xb_pkgd}/
      fi
    fi
    build_packages_filelist
    tar -czvf "${xb_distdir}.tar.gz" *
    rm -rf ${xb_distdir}
    popdir
  fi
}

build_dependencies(){
  local pkgfile=
  local stack
  local cf
  local ldir
  while [ -n "${1}" ]; do
    [ -f "./${1}.sh" ] || doErr "no script file ${1}.sh.\n  Aborting..."
    pkgfile=$(./${1}.sh ${arch} --get pc)
    libname=$(./${1}.sh --get libname)
    if [ ! -f "${pkgfile}" ]; then
      stack=($CSH $CBN $vrs)
      unset vrs CSH CBN
      ./${1}.sh ${arch} ${dep_build} || err
      CSH=${stack[0]}; CBN=${stack[1]}; vrs=${stack[2]};
    fi
    if [ -f "${pkgfile}" ]; then
      local cmi=$(./${1}.sh ${arch} --get cmake_include)
      [ -n "$cmi" ] && pushvar_f cmake_includes $cmi
      ldir="$(dirname ${pkgfile})"
      str_contains $PKG_CONFIG_LIBDIR ${ldir} || PKG_CONFIG_LIBDIR="${ldir}:${PKG_CONFIG_LIBDIR}"
    fi
    shift
  done
}

#usage: meson_create_toolchain <out.meson.file>
meson_create_toolchain(){
  local cpuf=(aarch64 arm x86 x86_64)
  local cpuc=(aarch64 arm i686 x86_64)
  cmake_create_toolchain ${BUILD_DIR}
  cat <<-EOF >${1}
		[binaries]
		c = '${CC}'
		c_ld = '${LD}'
		cpp = '${CXX}'
		cpp_ld = '${LD}'
		ar = '${AR}'
		as = '${AS}'
		pkgconfig = 'pkg-config'
		addr2line = '${ADDR2LINE}'
		objcopy = '${OBJCOPY}'
		objdump = '${OBJDUMP}'
		ranlib = '${RANLIB}'
		readelf = '${READELF}'
		size = '${SIZE}'
		strings = '${STRINGS}'
		strip = '${STRIP}'
		windres = '${WINDRES}'

		[properties]
		needs_exe_wrapper = true
		cmake_toolchain_file = '${cmake_toolchain_file}'
	
		[host_machine]
		system = '${host_os}'
		cpu_family = '${cpuf[$p_id]}'
		endian = 'little'
		cpu = '${cpuc[$p_id]}'

		[target_machine]
		system = '${host_os}'
		cpu_family = '${cpuf[$p_id]}'
		endian = 'little'
		cpu = '${cpuc[$p_id]}'
		EOF
  echo "\nMeson file:(${1})\n\n" >>${LOGFILE} 2>&1
  cat ${1} >>${LOGFILE} 2>&1
}

cmake_include_directories(){
  printf "include_directories($@)" >> $cmake_toolchain_file
}


# usage cmake_create_toolchain <dir>
cmake_create_toolchain(){
  export cmake_toolchain_file="${ROOTDIR}/xbuilder.cmake"
}

cargo_create_toolchain(){
  cat <<-EOF >>cargo-config.toml
  [target.aarch64-linux-android]
  ar = "${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar"
  linker = "${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android${API}-clang"

  [target.arm-linux-androideabi]
  ar = "${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar"
  linker = "${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/armv7a-linux-androideabi${API}-clang"

  [target.i686-linux-android]
  ar = "${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar"
  linker = "${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/i686-linux-android${API}-clang"

  [target.x86_64-linux-android]
  ar = "${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar"
  linker = "${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/x86_64-linux-android${API}-clang"
	EOF
}

# usage: check_tool_dependency <exe-name> <pkg-name>. returns path of exe-name
check_tool_dependency(){
  local nm
  local pk
  if [ -n "$1" ];then
    nm=$1
    [ -n "$2" ] && pk=$2 || pk=$1
    [ -z $(which $nm) ] && aptInstall $pk
    nm=$(which $nm)
  fi
  echo $nm
}


check_tools(){
  while [ -n "$1" ]; do
  toolname=$1
  toolpkg=$1
  case $1 in
    rust ) installRust && continue;;
    libtool ) toolname=libtoolize;;
    texinfo ) toolname=makeinfo;;
    autotools )  chkAutotools && continue;;
    * ) ;;
  esac
  [ -z $(which $toolname) ] && aptInstall $toolpkg
  shift
  done
}

# usage: chkTools tools...
chkAutotools(){
  if [ -z $(which automake) ];then
    tput sc
    $sudo apt -qq install automake autogen autoconf m4 libtool-bin -y >/dev/null 2>&1 
    tput rc
  fi
}

# make args...
doMake(){
  make $@ 2>&1 | tee -a $LOGFILE | grep -Eo "\[.+%\]" 
}

errCall(){
  echo -e "$(
    cat <<-EOM
			\n$CWtcutils $vrs
			${C0}Cannot be called directly. Missing vars lib arch or src
			\n
			EOM
)"
exit 1  
}

secs2time(){
  [ $(($1/60%60)) -eq 0 ] && printf '%ds' $(($1%60)) || printf '%dm %ds' $(($1/60%60)) $(($1%60))
  
}

log_start(){
  logtime_start=$(date +%s)
  #echo -ne "$CC1  $@: "
  echo -ne "${C0}${ind}$(date '+%H:%M')"
  [ $eta ] && echo -ne "-${CW}$(date '+%H:%M' --date="$eta seconds")"
  printf " ${CT1}%-10s ${CT1}%-21s${CD} " ${lib} ${arch}
}

log_end(){
  if [ -n "${logtime_start}" ]; then
    logtime_end=$(date +%s)
    #local pkgsize=$(du -sk ${INSTALL_DIR} | cut -f1)
    #local libsize=$(du -sk ${INSTALL_DIR}/lib | cut -f1)
    local secs=$(($logtime_end-$logtime_start))
    local msg="${CT1} done ${CD}in $(secs2time ${secs})"
    [ $secs -gt 60 ] && msg="$msg (${secs}s)"
    #echo -e "$msg pkg/lib: ${pkgsize}/${libsize}kb${C0}"
    echo -e "$msg"
  fi
}

log(){
  echo -ne "$CD$@$C0"
}

log_vars(){
  while [ -n "$1" ]; do
    echo "$1=${!1}" >>$LOGFILE 2>&1
    shift
  done
  echo >>$LOGFILE
}

doErr(){
  echo -e "${CR1}  Error: ${CR0}${1}${C0}\n\n"
  if [ -f $LOGFILE ];then
    if [ -f ${BUILD_DIR}/CMakeFiles/CMakeError.log ];then
      echo -e "\n\n${BUILD_DIR}/CMakeFiles/CMakeError.log:\n" >> $LOGFILE
      cat ${BUILD_DIR}/CMakeFiles/CMakeError.log >> $LOGFILE
    fi
    echo -ne "${CY1}${ind}Open log? [Y|n]:${C0}" && read openlog
    [ "$openlog" != "n" ] && nano $LOGFILE
  fi
  exit 1
}

err(){
  if [ -n "${logtime_start}" ]; then
    logtime_end=$(date +%s)
    echo -e "${CR1} fail ${CR0}[$(secs2time $(($logtime_end-$logtime_start)))]${C0}\n"
  fi
  if [ -f $LOGFILE ];then
    if [ -f ${BUILD_DIR}/CMakeFiles/CMakeError.log ];then
      echo -e "\n\n${BUILD_DIR}/CMakeFiles/CMakeError.log:\n" >> $LOGFILE
      cat ${BUILD_DIR}/CMakeFiles/CMakeError.log >> $LOGFILE
    fi
    echo -ne "${CY1}${ind}Open log? [Y|n]:${C0}" && read openlog
    [ "$openlog" != "n" ] && nano $LOGFILE
  fi
  echo
  exit 1
}

log_this() {
  echo -e "\n$(date +"%T"): $@" >> "$LOGFILE"
  "$@" 2>> "$LOGFILE" 1>> "$LOGFILE" || err
  logok
}

doLogNoErr(){
  local var=$1; shift
  echo -ne "${CD}${var}${C0}"
  echo -e "\n$(date +"%T"): $@" >> "$LOGFILE"
  "$@" 2>> "$LOGFILE" 1>> "$LOGFILE"
  logok $var
}

doNoLog(){
  local var=$1; shift
  echo -ne "${CD}${var}${C0}"
  echo -e "\n$(date +"%T"): $@" >> "$LOGFILE"
  "$@" 2>&1 >/dev/null
  logok $var
}

doLog() {
  local var=$1; shift
  echo -ne "${CD}${var}${C0}"
  log_this $@
  logok $var
}

doLogP() {
  local var=$1; shift
  echo -ne "${CD}${var}"
  echo -e "\n$(date +"%T"): $@" >> "$LOGFILE"
  ("$@" |& tee -a $LOGFILE | topct) || doErr "in ${var}:\n\n...\n$(tail -n5 $LOGFILE)${C0}"
  logok $var
}

logok() {
  echo -ne "\e[${#1}D${CT0}${1}${C0} "
}

# usage logver /path/to/pkgconfigfile.pc
logver() {
  if [ -f $1 ];then
    echo -ne "${CT1}version $(pkg-config --modversion $1)${C0}"
  else
    echo -ne "${CS0} missing ${1} ${C0}"
  fi
}

inlineCcmake(){
  tput sc; ccmake $@; tput rc
}

isBottomRow(){
  test "$(echo "lines"|tput -S)" == "$(IFS=';' read -sdR -p $'\e[6n' ROW COL && echo "${ROW#*[}")" && echo 1 || echo 0
}

# usage: do_git giturl [libname]
do_git(){
  doLog 'git' git clone $1 $2
  cd $2
  [ -n "${vrs}" ] && doLog ${vrs} git checkout tags/${vrs}
  [ -n "${sub}" ] && doLog 'sub' git ${sub}
  cd ..
}

topct(){
  printf "%-6s"
  local sln
  while read -r ln; do
    str_contains $ln 'error: ' && printf $CR1
    sln=$(grep -oP '\d+%' <<< $ln)
    [ -n "$sln" ] && printf "\e[5D%-5s" $sln
  done
  printf "\e[6D"
}

git_clone(){
  local var="git"
  echo -ne "${CD}${var}"
  git clone --progress --verbose $1 $2 $src_opt|& tr '\r' '\n' | topct
  logok $var
  [ -d "$2" ] && cd $2 || err
  $build_stable && vrs=$(git describe --abbrev=0 --tags)
  if [ -n "${vrs}" ];then
    doLog ${vrs} git checkout tags/${vrs};
  fi
  cd ..
}

do_svn(){
  local var="svn"
  echo -ne "${CD}${var}"
  svn checkout $1 $2 >/dev/null || err
  logok $var
}

do_hg(){
  [ $(which hg) ] || aptInstall mercurial || err
  doLog 'clone' hg clone $1 $2
}

set_git_version(){
  pushdir $SRCDIR
  local v=$(git describe --abbrev=0 --tags 2>/dev/null)
  [ -n "$v" ] && export vrs=$v
  popdir
}

githubLatestTarGz(){
  case $src in
    *github.*)
      local dst=$(echo $src | sed -e 's|\.git||g')
      local url=$(curl -ILs -o /dev/null -w %{url_effective} "${dst}/releases/latest")
      local file=$(curl -s $url | grep -Po '(?<=>)[^<]*' | grep -Po '.*tar.gz$')
      echo "${url}/${file}"
      ;;
    *gitlab.*|*code.videolan.org*)
      local dst=$(echo $src | sed -e 's|\.git||g')
      local v=$(git_remote_version $src)
      echo "$dst/-/archive/${v}/${lib}-${v}.tar.gz"
      ;;
    *.googlesource.*)
      local tag=$(git -c 'versionsort.suffix=-' ls-remote --refs --sort='v:refname' $src | tail -n1 | cut -f1)
      echo "$src/+archive/${tag}.tar.gz"
      ;;
    esac
}

# usage: wget_tarxx type url libname
wget_tarxx(){
  local tag="get"
  local args=
  echo -ne "${CD}${tag}${C0}"
  echo "$(date): $@" >> "$LOGFILE"
  
  case $src in
    *.tar.lz) args="--lzip -xv";;
    *.tar.gz|*.tgz) args="-xvz";;
    *.tar.xz) args="-xvJ";;
    *.tar.bz2) args="-xv";;
  esac

  [ -d "tmp" ] && rm -rf tmp
  mkdir tmp
  wget -qO- $1 2>>$LOGFILE | tar --transform 's/^dbt2-0.37.50.3/dbt2/' $args -C tmp >/dev/null 2>&1 || err
  cd tmp
  mv * $2 && mv $2 ..
  cd ..
  rm -rf tmp
  
  #if [ ! -f "${2}" ];then
  #  local fname=$(basename $src | sed -E 's/[0-9\.-_].*//')
  #  mv ${fname}* $2
  #fi
  logok $tag
}

wget_tar(){
  local tag="source"
  local args=
  echo -ne "${CD}${tag}${C0}"
  echo -e "\n\n$@\n----------------------------------------\n" >> "$LOGFILE"
  echo "$(date): $@" >> "$LOGFILE"
  case $sty in
    tlz|tar_lz) args="--lzip -xv";;
    tgz|tar_gz) args="-xvz";;
    txz|tar_xz) args="-xvJ";;
    tbz|tar_bz) args="-xv";;
  esac
  wget -qO- $src 2>>$LOGFILE | tar --transform 's/^dbt2-0.37.50.3/dbt2/' $args >/dev/null 2>&1 || err
  mv ${1}* ${lib}
  echo -e "----------------------------------------\n" >> "$LOGFILE"
  logok $tag
}

getZip(){
  [ -z $(which unzip) ] && aptInstall unzip
  log download
  wget $1 -O tmp.zip || err
  log extract unzip tmp.zip
  rm tmp.zip
  logok
}

prtPrc(){
  local v=$(grep "%")
}


makeClean(){
  pushdir $1
  make clean
  popdir
}

clean(){
  echo -ne "${CT0}\n\tcleaning...\n"
  rm -rf builds/$arch/$lib builds/$arch/$lib.log
  pushdir sources/$lib
  [ -f Makefile ] && make clean
  popdir
  echo -e "$C0\tdone"
  clear
}

cmakeClean(){
  pushdir $1
  rm -rf CMakeFiles CMakeCache.txt
  popdir
}

showOpts(){
  if [ -d "$1" ] && [ -n "$lib" ];then
    local bdir=$(pwd)/builds
    pushd $1>/dev/null
    [ -f CMakeLists.txt ] && cmake -LA | awk '{if(f)print} /-- Cache values/{f=1}' >${bdir}/${lib}_cmake.opts && nano "${bdir}/${lib}_cmake.opts"
    [ -f configure ] && ./configure --help >${bdir}/${lib}_aconf.opts && nano "${bdir}/${lib}_aconf.opts"
    popdir
  else
    echo -e "${ind}${CR0}no configuration file found in ${CR1}$1${CD}\n\n"
  fi
}

setCMake(){
  printf "SET($2 $3)\n\n" >> $1
}

doAutogen(){
  [ $1 ] || doErr "missing arg in doAutogen: usage doAutogen <AUTOGEN_DIR>"
  local var="autogen"
  echo -ne "${CD}${var}${C0}"
  pushdir $1
  shift
  case $1 in
    --noerr ) ./autogen.sh >>$LOGFILE 2>&1;;
    --noconfigure ) NOCONFIGURE=1 log_this ./autogen.sh;;
    * ) log_this ./autogen.sh;;
  esac
  popdir
  logok $var
}

doAutoreconf(){
  local var="autoreconf"
  echo -ne "${CD}${var}${C0}"
  pushdir $1
  log_this autoreconf -fi
  popdir
  logok $var
}

checkUrl(){
  wget -S --spider $1 2>&1 | grep -q "HTTP/1.[0-9] 200 OK" && echo SUCCESS || echo FAIL
}

checkCmd(){
  [ -z "$(which $1)"] $sudo apt -qq install $1 -y >/dev/null 2>&1
}

downloadP(){
  tput sc && echo -ne "\e[$(tput lines);0H${CY1}"
  # wget --progress=dot $url 2>&1 | grep --line-buffered "%" | sed -u -e "s,\.,,g" | awk '{printf("\b\b\b\b%4s", $2)}'
  wget --progress=dot $1 2>&1 | grep --line-buffered "%" | sed -u -e "s,\.,,g" | awk '{printf("\r%4s %s eta:%s  ",$2,$1,$4)}'
  tput rc
  echo "${C0} ok "
}

download(){
  # bsdtar from stdin doesn't extract file +x permission
  # wget -qO- $1 | bsdtar -xvf- >/dev/null 2>&1
  echo -ne " ${CD}checking tools"
  test -z $(which unzip) && aptInstall unzip
  echo -ne " ${CS0}downloading..."
  tput sc && echo -ne "\e[$(tput lines);0H${CY1}"
  wget --progress=dot $1 -O tmp.zip 2>&1 | grep --line-buffered "%" | sed -u -e "s,\.,,g" | awk '{printf("\r%4s %s eta:%s  ",$2,$1,$4)}'
  tput rc
  echo -ne "${CS0} decompressing... ${C0}"
  unzip tmp.zip >/dev/null 2>&1 && rm tmp.zip || err
}

patch_ndk_libpthread(){
  if [ "${host_os}" == "android" ]; then
    # NDK Patch: create missing libpthread in NDK
	  local lpthread="${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/lib/${arch}/libpthread.a"
	  [ ! -f $lpthread ] && ${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64//bin/llvm-ar cr $lpthread
  fi
}

patch_ndk_librt(){
  if [ "${host_os}" == "android" ]; then
    # NDK Patch: create missing librt in NDK
    local lrt="${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/lib/${arch}/librt.a"
    [ ! -f $lrt ] && ${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64//bin/llvm-ar cr $lrt
  fi
}

# usage: patch_zlib_createpc <sysroot-prefix>
_patch_zlib_createpc(){
  [ -d "$LIBSDIR/lib/pkgconfig" ] && mkdir -p "$LIBSDIR/lib/pkgconfig"
  cat <<-EOF >$LIBSDIR/lib/pkgconfig/zlib.pc
  prefix=${1}
  libdir=\${prefix}/lib/${arch}
  includedir=\${prefix}/include

  Name: zlib
  Description: zlib compression library
  Version: 1.2.11
  Libs: -L\${libdir} -lz
  Cflags: -I\${includedir}
	EOF
}


aptInstall(){
  while [ "$1" != "" ];do
    #echo -ne "  ${CT0}install $1${C0}"
    #echo -n " "
    stty size | {
      read y x
      echo -ne "${CY1}"
      tput sc
      tput cup "$((y - 1))" 0
      $sudo apt -qq install $1 -y >/dev/null 2>&1
      echo -ne "${C0}"
      tput rc
    }
    #echo -ne "${C0} ok"
    shift
  done
}

set_ndk_api(){
  API=${1}
  set_host $cpu_id
}

ndk_assert_h_sys_soundcard(){
  [ "$host_os" == "android" ] && \
    [ ! -f "$SYSROOT/usr/include/sys/soundcard.h" ] && \
    echo "#include <linux/soundcard.h>" >"$SYSROOT/usr/include/sys/soundcard.h" 
  return 0
}

getMinGwVersion(){
  echo $(x86_64-w64-mingw32-gcc --version | head -n1 | grep -Eo "(GCC).+-win32" | sed 's|GCC) \(.*\)-win32|\1|')
}

errUnknownTarget(){
  if [ $arch ];then
    echo -e "\n${ind}${CR1}unknown target ${arch}${C0}\n" && exit 1
  else
    echo -e "\n${ind}${CR1}must specify a target${C0}\n" && usage && exit 1
  fi
}

clearAll(){
  if [ -z "$lib" ];then
    read -p 'Clear all data? (Builds, Sources and Logs) [Y|n] ' ca
    case $ca in Y|y) rm -rf builds sources && clear;;esac
  else
    rm -rf sources/$lib
    [ -n "$arch" ] && rm -rf builds/$arch/$lib builds/$arch/$lib.log
  fi
}

checkPkg(){
  local pf="$LIBSDIR/lib/pkgconfig/${pkg}.pc"
  [ -f "$pf" ] && echo $pf
  return 0
}

usage(){
  echo -e "$(
  cat <<-EOF
    \n
    ${CW}usage: $0 ${CC1}<target> ${CB1}<build-options> ${CM1}<builder-options> ${CM0}<other-options>${C0}\n
    ${CC1}<target>
    ${CC1}<android> ${C0}\taarch64-linux-android | arm-linux-androideabi | i686-linux-android | x86_64-linux-android
    ${CC1}<linux>   ${C0}\taarch64-linux-gnu     | arm-linux-gnueabihf   | i686-linux-gnu     | x86_64-linux-gnu
    ${CC1}<windows> ${C0}\ti686-w64-mingw32      | x86_64-w64-ming32\n
    ${CB1}<build-options>
    ${CB1}--shared  ${C0}\tbuild shared/dynamic libs
    ${CB1}--static  ${C0}\tbuild static libs
    ${CB1}--bin     ${C0}\tbuild executables
    ${CB1}--nobin   ${C0}\tdon't build executables
    ${CB1}--prefix d${C0}\tset build directory <d>
    ${CB1}--api n   ${C0}\tset api level <n>
    ${CB1}--stable  ${C0}\tuse git stable branch\n
    ${CM1}<builder-options>
    ${CM1}--cmake   ${C0}\tforce cmake build when available
    ${CM1}--ndkcmake${C0}\tuse android ndk cmake 3.10.2 instead
    ${CM1}--ccmake  ${C0}\tforce cmake + gui ccmake when available
    ${CM1}--vrep    ${C0}\tget repository version
    ${CM1}--checkPkg${C0}\tget pkgconfig file's path\n
    ${CM0}<other-options>
    ${CM0}--get <o> ${C0}\tdelete all (builds + sources)
    ${CM0}   cflags ${C0}\tpkgconfig cflags
    ${CM0}   libs   ${C0}\tpkgconfig link flags
    ${CM0}   ldstatic${C0}\tpkgconfigstatic link flags
    ${CM0}   pc-ver ${C0}\tpkgconfig lib version
    ${CM0}   pc-path${C0}\tpkgconfig.pc file path
    ${CM0}   pc-name${C0}\tfilename (without .pc)
    ${CM0}   prefix ${C0}\tinstall prefix path
    ${CM0}   libname${C0}\tlib name
    ${CM0}   aptname${C0}\tdebian package name for lib
    ${CM0}--wipeall ${C0}\tdelete all (builds + sources)
    ${CM0}--update  ${C0}\tforce source update/download (git/svn/etc)
    ${CM0}--rebuild ${C0}\tforce remake project
    ${CM0}--retry   ${C0}\tretry build without clear cache
    ${CM0}--clean   ${C0}\tclean up last build
    ${CM0}--clearsrc${C0}\tdelete source
    ${CM0}--opts    ${C0}\tshow available configuration options/flags
    ${CM0}--nobanner${C0}\tdon't show banner/packageinfo\n\n
EOF
)" 
}

hwinfoCountCores(){
  cat /proc/cpuinfo | grep -Po -c 'model name\s+: \K(.*)'
}

hwinfoCountCoresReadable(){
  case $(nproc) in
    "1") echo "Single-Core";;
    "2") echo "Dual-Core";;
    "4") echo "Quad-Core";;
    "6") echo "Hexa-Core";;
    "8") echo "Octa-Core";;
    *) echo "$n-Core";;
  esac
}

hwinfoProcessor(){
  cat /proc/cpuinfo | grep -Po 'model name\s+: \K(.*)' | head -n1
}

showBanner(){
  if $banner; then
    echo -ne "\n\n${ind}${CW}Cross Compile Shell Scripts ${vsh} for Linux${C0}\n${ind}"
    [ -n $(which lsb_release) ] && echo -ne "$(lsb_release -sd) "
    if [ -n "$(uname -r | grep 'microsoft')" ];then
      echo -ne "WSL2 "
    elif [ -n "$(uname -r | grep 'Microsoft')" ];then
      echo -ne "WSL "
    fi
    echo -e "$(uname -o) $(uname -m) ${C0} $(uname -r)"
    echo -e "${CW}${ind}$(hwinfoCountCoresReadable) $(hwinfoProcessor)${C0}"
  fi
}

# main
main $@